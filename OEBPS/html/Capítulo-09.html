<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" lang="en">

<head>
  <title>Introducing Docker</title>
  <link href="../css/springer_epub.css" rel="styleSheet" type="text/css"/>
</head>

<body>

  <div epub:type="chapter" role="doc-chapter">

    <div class="ChapterContextInformation">

      <div class="ContextInformation" id="b979-8-8688-0555-4_7"><div class="ChapterCopyright">© The Author(s), under exclusive license to APress Media, LLC, part of Springer Nature 2024</div><span class="ContextInformationAuthorEditorNames">B. A. Christudas</span><span class="ContextInformationBookTitles"><span class="BookTitle">Java Microservices and Containers in the Cloud</span></span><span class="ChapterDOI"><a href="https://doi.org/10.1007/979-8-8688-0555-4_7">https://doi.org/10.1007/979-8-8688-0555-4_7</a></span></div>

    </div>

    <!--Begin Abstract-->

    <div class="MainTitleSection">

      <h1 class="ChapterTitle" lang="en">7. Introducing Docker</h1>

    </div>

    <div class="AuthorGroup">

      <div class="AuthorNames"><span class="Author"><span class="AuthorName">Binildas A. Christudas</span><sup><a href="#Aff2">1</a> <span class="ContactIcon"> </span></sup></span></div>

      <div class="Affiliations">

        <div class="Affiliation" id="Aff2"><span class="AffiliationNumber">(1)</span><div class="AffiliationText">NBCRA 45, Christbin, Thiruvananthapuram, Kerala, India</div></div>

        <div class="ClearBoth"> </div>

      </div>

    </div>

    <!--End Abstract-->

    <div class="Fulltext">

      <p class="Para" id="Par2">Resource and time sharing are not new and were generally believed to originate in the IBM mainframe days of the late 1960s and early 1970s. <span id="ITerm1">Virtualization</span> was made possible for organizations and individuals to use a computer resource without owning one. The capacity of a single server is so large that it is almost impossible for the majority of general-purpose workloads to effectively use it, so shared use among a large group of applications and users makes sense. The goal was to increase the efficiency of the users and the expensive computer resources they shared and this paved the road to virtualization.</p>

      <p class="Para" id="Par3"><span id="ITerm2">Containers</span> are a form of operating system virtualization. Containers have no or lean operating system images, but greatly utilize the host operating system. A set of characteristics make containers attractive, especially in deploying microservice-based applications, and they are explored in this chapter.</p>

      <div class="Para" id="Par4">The following topics are covered in this chapter:<div class="UnorderedList"><ul class="UnorderedListMarkBullet"><li><p class="Para" id="Par5">Virtualization in general</p></li><li><p class="Para" id="Par6">Introduction to containers</p></li><li><p class="Para" id="Par7">Docker in detail</p></li><li><p class="Para" id="Par8">Compiling, packaging, and running a Java app without a local Java Installation</p></li><li><p class="Para" id="Par9">Running your first Java container</p></li></ul></div></div>

      <section class="Section1 RenderAsSection1" id="Sec1">

        <h2 class="Heading">Different Types of Virtualization</h2>

        <div class="Para" id="Par10">This discussion begins with the traditional mode of application deployment and then moves to various ways of virtualization so that you can appreciate some of the advantages containers offer as compared to peer methods of virtualizations.<figure class="Figure" id="Fig1"><div class="MediaObject" id="MO1"><img alt="" aria-describedby="d64e196" src="../images/619782_1_En_7_Chapter/Imagem-072.jpg" style="width:35.15em"/><div class="TextObject" id="d64e196"><p class="Para" id="Par154">3 block diagrams compare 3 types of virtualization. Traditional virtualization has a single application, while virtual machines have a guest operating system and a virtual machine, and containers have a minimal guest operating system and a container box. Each has hardware and application.</p></div></div><figcaption class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Figure 7-1</span><p class="SimplePara"><span id="ITerm3">Traditional vs. VMs vs. containers</span></p></div></figcaption></figure></div>

        <p class="Para" id="Par11">Referring to Figure <span class="InternalRef"><a href="#Fig1">7-1</a></span>, first consider the different modes of virtualizations and application deployment.</p>

        <section class="Section2 RenderAsSection2" id="Sec2">

          <h3 class="Heading">Traditional Deployment</h3>

          <p class="Para" id="Par12">In the traditional or classical <span id="ITerm4">mode</span> of application deployment, organizations used physical servers. Every time the business needed a new application, the IT department would buy a new server. Since many times nobody knew the performance requirements of the new application, and to provide enough headroom for future business volume growth, the IT department would over-purchase. They used guesswork to determine the model and size of the server to buy.</p>

          <div class="Para" id="Par13">The typical lifecycle of provisioning application software flows like this:<div class="OrderedList"><ol><li class="ListItem"><div class="ItemNumber">1.</div><div class="ItemContent"><p class="Para" id="Par14">Get the physical servers ready in the data center.</p></div><div class="ClearBoth"> </div></li><li class="ListItem"><div class="ItemNumber">2.</div><div class="ItemContent"><p class="Para" id="Par15">Install or use an existing operating system.</p></div><div class="ClearBoth"> </div></li><li class="ListItem"><div class="ItemNumber">3.</div><div class="ItemContent"><p class="Para" id="Par16">Install any additional tools needed by your application software.</p></div><div class="ClearBoth"> </div></li><li class="ListItem"><div class="ItemNumber">4.</div><div class="ItemContent"><p class="Para" id="Par17">Install any dependencies for your software.</p></div><div class="ClearBoth"> </div></li><li class="ListItem"><div class="ItemNumber">5.</div><div class="ItemContent"><p class="Para" id="Par18">Run your software.</p></div><div class="ClearBoth"> </div></li><li class="ListItem"><div class="ItemNumber">6.</div><div class="ItemContent"><p class="Para" id="Par19">Retire your application.</p></div><div class="ClearBoth"> </div></li><li class="ListItem"><div class="ItemNumber">7.</div><div class="ItemContent"><p class="Para" id="Par20">Repurpose or recycle server hardware.</p></div><div class="ClearBoth"> </div></li></ol></div></div>

          <p class="Para" id="Par21">A much better way to utilize capital expenses is to use virtualization, which is discussed next.</p>

        </section>

        <section class="Section2 RenderAsSection2" id="Sec3">

          <h3 class="Heading">Virtualization</h3>

          <p class="Para" id="Par22">When VMware, Inc. brought the <span id="ITerm5">Virtual Machine (VM)</span> concept, IT departments no longer needed to procure a new, oversized server every time they needed a new application. Instead, IT could run new apps on existing servers that were sitting around with spare capacity. Virtualization allows IT to run multiple VMs on a single physical server. Each VM includes a full copy of an operating system, the application, necessary binaries, and libraries.</p>

          <div class="Para" id="Par23">The essential component in the virtualization stack is the <span id="ITerm6"><em class="EmphasisTypeItalic ">hypervisor</em></span>, also called the <span id="ITerm7">Virtual Machine Monitor (VMM)</span>. It creates a virtual platform on the host computer, on top of which multiple guest operating systems are executed and monitored. These multiple operating systems are either different instances of the same operating system, or different operating systems. They share the hardware resources offered by the same, single host. <span id="ITerm8">Hypervisor</span>s have classifications:<div class="UnorderedList"><ul class="UnorderedListMarkBullet"><li><p class="Para" id="Par24"><strong class="EmphasisTypeBold ">Type 1, native or bare metal:</strong> <span id="ITerm9">Native hypervisors</span> run directly on the host’s hardware to control the hardware, and to monitor the guest OS. Consequently, the guest OS runs on a separate level above the hypervisor. Examples: Oracle VM, Microsoft Hyper-V, VMWare ESX, and Xen.</p></li><li><p class="Para" id="Par25"><strong class="EmphasisTypeBold ">Type 2, hosted:</strong> <span id="ITerm10">Hosted hypervisors</span> run within a traditional OS. Hosted hypervisors add a distinct software layer to top of the host OS, and the guest OS becomes a third software level above the hardware. Examples: Oracle VM VirtualBox, VMWare Server and Workstation, Microsoft Virtual PC, KVM, QEMU, and Parallels.</p></li></ul></div></div>

          <div class="Para" id="Par26">The fact that every VM requires its own dedicated <span id="ITerm11">operating system (OS)</span> is a major flaw. Every OS consumes CPU, RAM, and other resources. Every OS needs licensing, patching, and monitoring. There are other <span id="ITerm12">challenges</span> too, a few of which are listed here:<div class="UnorderedList"><ul class="UnorderedListMarkBullet"><li><p class="Para" id="Par27">Operating system images are heavyweight—in the GBs.</p></li><li><p class="Para" id="Par28">It is a slow-to-boot-up process.</p></li><li><p class="Para" id="Par29">The applications are not portable.</p></li><li><p class="Para" id="Par30">Spinning up a virtual machine may take 1–2 minutes.</p></li></ul></div></div>

          <p class="Para" id="Par31">Docker Container was introduced in 2013 to address these drawbacks.</p>

        </section>

        <section class="Section2 RenderAsSection2" id="Sec4">

          <h3 class="Heading">Containers</h3>

          <p class="Para" id="Par32"><span id="ITerm13">Containers</span><span id="ITerm14"></span> use OS level virtualization. They do not require their own full-blown OS. Instead, all containers on a single host share the host’s OS. This frees up huge amounts of system resources, including CPU, RAM, and storage. It also reduces potential licensing costs and reduces the overhead of OS patching and other maintenance. Container abstraction at the OS layer packages code and dependencies together.</p>

          <p class="Para" id="Par33">Containers are also fast to start and ultra-portable. Containers are very lightweight and can spin up in a few seconds or milliseconds. Container workloads can be moved from laptops to the cloud, and then to VMs or bare metal in your data center quickly and easily.</p>

        </section>

      </section>

      <section class="Section1 RenderAsSection1" id="Sec5">

        <h2 class="Heading">Containers in Detail</h2>

        <p class="Para" id="Par34">Understanding containers is essential for understanding the rest of this chapter, hence this section is devoted to containers.</p>

        <section class="Section2 RenderAsSection2" id="Sec6">

          <h3 class="Heading">History of Containers</h3>

          <div class="Para" id="Par35">Let’s consider a brief <span id="ITerm15">history</span> of containers. Around 2000, Jails, an early implementation of container technology, was added to FreeBSD. The next year, the Linux VServer project made running several general-purpose Linux servers on a single box a reality. This separated the userspace environment into distinct units—called Virtual Private Servers—so that each VPS looked and felt like a real server to the processes contained within. In 2006, the “Generic Process Containers” was put forward. This was renamed Cgroups (Control Groups) and it allowed processes to be grouped together and ensured that each group got a share of memory, CPU, and disk I/O while at the same time preventing any one container from monopolizing any of these resources. Adding to this is the notion of Kernel namespaces, which separated it from user namespaces. User namespaces allow a process to have its own set of users and allow a process to have root privileges inside a container, but not outside. In 2008, IBM created the <span id="ITerm16">Linux Containers Project (LXC)</span>. LXC 1.0 was released in 2014. SELinux and Seccomp are two new features:<div class="UnorderedList"><ul class="UnorderedListMarkBullet"><li><p class="Para" id="Par36"><strong class="EmphasisTypeBold ">Seccomp:</strong> <span id="ITerm17">Seccomp</span> is a Linux kernel feature for limiting the system calls that a task can use. This allows an underutilized CPU to be rented out to untrusted guests without fearing they will abuse other resources, which is a good fit for container use case.</p></li><li><p class="Para" id="Par37"><strong class="EmphasisTypeBold ">SELinux:</strong> <span id="ITerm18">SELinux</span> has an access control schema for “labeling processes, files, and devices and at defining rules on how labeled processes interact with labeled processes, files, and devices.” Linux containers, as a group of processes, are a good match for hardening with SELinux, another idea that maps to the container use case.</p></li></ul></div></div>

          <p class="Para" id="Par38"><span id="ITerm19">Docker</span> built on all of these features incrementally and wrapped the LXC userspace tools to make them even easier for developers to use. In June 2015, Docker the company open sourced Docker to OCI (Open Container Initiative) under the auspices of the Linux Foundation. Docker initially used the LXC driver, then moved to <span class="EmphasisFontCategoryNonProportional ">libcontainer</span>, which is now renamed <span class="EmphasisFontCategoryNonProportional ">runc</span>.</p>

        </section>

        <section class="Section2 RenderAsSection2" id="Sec7">

          <h3 class="Heading">Container Internals</h3>

          <p class="Para" id="Par39">The <span id="ITerm20">namespace</span> is a Kernel level feature. This function of the OS allows global resources, like network and disks among processes, to be shared. When global resources were wrapped in namespaces, they become visible only to those processes that run in the same namespace. For example, when you get a portion of disk and put it in one namespace, processes running in another namespace can’t see or access it. Similarly, processes in one namespace can’t access anything in memory that is allocated to another namespace, and so on. Of course, processes in namespace A can’t see or talk to processes in namespace B. This way, global resources can be virtualized and isolated. Docker works in this manner—each Docker container runs in its own namespace but uses the same kernel as all the other containers. The isolation happens because the kernel knows the namespace that was assigned to the process. During an API call, it makes sure that the process can only access resources in its own namespace.</p>

        </section>

        <section class="Section2 RenderAsSection2" id="Sec8">

          <h3 class="Heading">Virtualization vs. Containerization</h3>

          <div class="Para" id="Par40">Having looked at the different levels of <span id="ITerm21">virtualization</span> options, this section investigates the underlying details. See Figure <span class="InternalRef"><a href="#Fig2">7-2</a></span>.<figure class="Figure" id="Fig2"><div class="MediaObject" id="MO2"><img alt="" aria-describedby="d64e464" src="../images/619782_1_En_7_Chapter/Imagem-073.jpg" style="width:35.15em"/><div class="TextObject" id="d64e464"><p class="Para" id="Par155">2 block diagrams compare virtual machines and containers. Virtual machines have a guest operating system. Containers have a minimal guest operating system. Both have bins, libraries, and an application. Virtual machine runs on a hypervisor, while container runs on an engine.</p></div></div><figcaption class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Figure 7-2</span><p class="SimplePara">VMs vs. containers</p></div></figcaption></figure></div>

          <p class="Para" id="Par41">Figure <span class="InternalRef"><a href="#Fig2">7-2</a></span> compares and contrasts the similarities and differences between <span id="ITerm22">virtualization</span> and containerization. This discussion is limited to Type 2 virtualization, which gives more contrast compared to containerization, even though almost all the aspects are applicable to Type 1 virtualization also.</p>

          <p class="Para" id="Par42">In this case of virtualization, the VM manager takes over the CPU ring 0 (which is also called the “root mode” in newer CPUs) and intercepts all privileged calls made by the guest OS to create the illusion that the guest OS has its own hardware. Virtualization thus allows you to run two completely different OSes on the same (single) underlying hardware. Each guest OS goes through the processes of bootstrapping, kernel loading, and so on. The guest OS can’t get full access to either the host OS or to other guest OSs and hence can’t mess things up. This provides tighter security.</p>

          <p class="Para" id="Par43">You may now be able to appreciate that while you could run multiple OS in virtualized hardware, you can’t run completely different OSes in containers like in virtualization. However, you can run different distros of Linux because they all share the same kernel. This means, since containers share the same kernel as the host, you can run an Arch image on an Ubuntu host.</p>

          <p class="Para" id="Par44">A system call (commonly abbreviated as <em class="EmphasisTypeItalic ">syscall</em>) is the programmatic way in which a program requests services from the kernel of the operating system on which it is executed. This may include hardware-related services (for example, accessing a hard disk drive or accessing the device’s I\O ports), creation and execution of new processes, and communication with integral kernel services such as process scheduling. syscalls provide an essential interface between a process and the operating system. Containers have access to the kernel of the host. Since the kernel is the only part that communicates with the hardware, as long as your OS uses the good syscall, you can run any Linux distribution inside your container. For the same the reason, you can’t use Windows inside a container since it’s not using the same syscall.</p>

        </section>

      </section>

      <section class="Section1 RenderAsSection1" id="Sec9">

        <h2 class="Heading">Docker Concepts</h2>

        <p class="Para" id="Par45">This section talks about Docker concepts and Docker containers.</p>

        <section class="Section2 RenderAsSection2" id="Sec10">

          <h3 class="Heading">Layered Filesystems</h3>

          <p class="Para" id="Par46"><span id="ITerm23">Docker</span> is based on <em class="EmphasisTypeItalic ">aufs</em> (short for <em class="EmphasisTypeItalic ">advanced multi-layered unification filesystem</em>), which implements Unionfs, a union mount for Linux filesystems. Unionfs is a filesystem service for Linux, FreeBSD, and NetBSD which implements a union mount for other filesystems. It allows files and directories of separate filesystems, known as <em class="EmphasisTypeItalic ">branches</em>, to be transparently overlaid, forming a single coherent filesystem. Several Linux distributions have chosen aufs as a replacement for UnionFS.</p>

          <p class="Para" id="Par47">A <em class="EmphasisTypeItalic ">union mount</em> is a mount that allows several filesystems to be mounted at one time and appear as one filesystem. The <span id="ITerm24">union mount</span> overlays the filesystems on top of one another so that the resulting filesystem may contain files and subdirectories from any or all of the underlying filesystems. In Docker vocabulary, each of these filesystems is called an <em class="EmphasisTypeItalic ">image</em>.</p>

        </section>

        <section class="Section2 RenderAsSection2" id="Sec11">

          <h3 class="Heading">Docker Images</h3>

          <div class="Para" id="Par48">A Docker <span id="ITerm25">image</span> is made up of filesystems layered over each other, as shown in Figure <span class="InternalRef"><a href="#Fig3">7-3</a></span>.<figure class="Figure" id="Fig3"><div class="MediaObject" id="MO3"><img alt="" aria-describedby="d64e554" src="../images/619782_1_En_7_Chapter/Imagem-074.jpg" style="width:29.6em"/><div class="TextObject" id="d64e554"><p class="Para" id="Par156">A 3-D model of a cuboid with three layers. The bottom layer is labeled Kernel. The center layer is labeled c groups, namespaces, and device mappers. The top layer is labeled boot f s.</p></div></div><figcaption class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Figure 7-3</span><p class="SimplePara">Docker bootfs</p></div></figcaption></figure></div>

          <p class="Para" id="Par49">At the base of the image is a boot filesystem, bootfs, which resembles the typical Linux/UNIX boot filesystem. When a container is booted, it is moved into memory, and the boot filesystem is unmounted to free up the RAM used by the initrd disk image. This is like a typical Linux virtualization stack so far. A Docker user may never interact with the boot filesystem.</p>

          <div class="Para" id="Par50">On top of the boot filesystem, Docker layers a root filesystem, <span id="ITerm26">rootfs</span>. This rootfs can be one or more operating systems (e.g., a Debian or Ubuntu). See Figure <span class="InternalRef"><a href="#Fig4">7-4</a></span>.<figure class="Figure" id="Fig4"><div class="MediaObject" id="MO4"><img alt="" aria-describedby="d64e582" src="../images/619782_1_En_7_Chapter/Imagem-075.jpg" style="width:35.15em"/><div class="TextObject" id="d64e582"><p class="Para" id="Par157">Two schematics of the layers of docker images. Image 1 has a Debian operating system with a kernel, Emacs, and Apache. Image 2 has a BusyBox operating system with a kernel.</p></div></div><figcaption class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Figure 7-4</span><p class="SimplePara">Docker images</p></div></figcaption></figure></div>

          <p class="Para" id="Par51">In traditional Linux boot, the root filesystem is mounted read-only and then switched to read-write after the boot is finished and an integrity check is conducted. In the Docker world, the root filesystem stays in read-only mode, and Docker leverages union mount to add more read-only filesystems over the root filesystem.</p>

          <div class="Para" id="Par52">Docker organizes the common parts of the operating system as read-only. Any common parts are shared <span id="ITerm27"></span>among all of your containers. See Figure <span class="InternalRef"><a href="#Fig5">7-5</a></span>.<figure class="Figure" id="Fig5"><div class="MediaObject" id="MO5"><img alt="" aria-describedby="d64e617" src="../images/619782_1_En_7_Chapter/Imagem-076.jpg" style="width:35.15em"/><div class="TextObject" id="d64e617"><p class="Para" id="Par158">A 3-D diagram of two rectangular prisms stacked on top of each other. The top is labeled image 1 and the bottom is labeled image 2. The top is divided into four layers, labeled Kernel, Debian, emacs, and Apache. The bottom is divided into two layers, labeled BusyBox and Kernel.</p></div></div><figcaption class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Figure 7-5</span><p class="SimplePara">Docker images <span id="ITerm28">sharing layers</span></p></div></figcaption></figure></div>

          <p class="Para" id="Par53">Sharing these common parts provides storage and runtime efficiency. To make it clear, if you have a 1GB container image and use a traditional VM method, you will need 1GB times the number of VMs you want. Since Docker shares the bulk of the 1GB between all the containers, if you have 1,000 containers, you still might only need a little over 1GB of space for all these containers (assuming they are all running the same OS image).</p>

          <div class="Para" id="Par54">Docker images are layered on top of one another. The image on the top is the parent image; you can traverse from one layer to its parent and so on until you reach the bottom of the image stack, where the final image is called the <span id="ITerm29">base image</span>. See Figure <span class="InternalRef"><a href="#Fig6">7-6</a></span>.<figure class="Figure" id="Fig6"><div class="MediaObject" id="MO6"><img alt="" aria-describedby="d64e653" src="../images/619782_1_En_7_Chapter/Imagem-077.jpg" style="width:35.15em"/><div class="TextObject" id="d64e653"><p class="Para" id="Par159">A process flow diagram of a container X with a write layer and four layers. The layers are connected to the write layer through the data and metadata. Each has a layer I D, metadata, data, and parent data.</p></div></div><figcaption class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Figure 7-6</span><p class="SimplePara"><span id="ITerm30">Anatomy</span> of a Docker image</p></div></figcaption></figure></div>

        </section>

        <section class="Section2 RenderAsSection2" id="Sec12">

          <h3 class="Heading">Docker Images vs. Containers</h3>

          <p class="Para" id="Par55">Docker images are read-only templates used to build <span id="ITerm31">containers</span>. Containers are deployed instances created from those templates. Images and containers are closely related and are essential in powering the Docker software platform.</p>

          <div class="Para" id="Par56">When a container is launched from an <span id="ITerm32">image</span>, Docker mounts a read-write filesystem on the top. In this read-write layer, whatever processes you want the Docker container to run will execute. Figures <span class="InternalRef"><a href="#Fig6">7-6</a></span> through <span class="InternalRef"><a href="#Fig8">7-8</a></span> represents this process.<figure class="Figure" id="Fig7"><div class="MediaObject" id="MO7"><img alt="" aria-describedby="d64e702" src="../images/619782_1_En_7_Chapter/Imagem-078.jpg" style="width:35.15em"/><div class="TextObject" id="d64e702"><p class="Para" id="Par160">A 3-D diagram of two rectangular prisms stacked on top of each other. The top is labeled Container 1 and the bottom is labeled Container 2. The top is divided into four layers, labeled Kernel, Debian, emacs, and Apache. The bottom is divided into two layers, labeled BusyBox and Kernel.</p></div></div><figcaption class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Figure 7-7</span><p class="SimplePara">Docker containers <span id="ITerm33">sharing image layers</span></p></div></figcaption></figure></div>

          <div class="Para" id="Par57">Even if containers share the same images (layers), once they are instantiated from their image templates, they are separate and isolated, as shown in Figure <span class="InternalRef"><a href="#Fig8">7-8</a></span>.<figure class="Figure" id="Fig8"><div class="MediaObject" id="MO8"><img alt="" aria-describedby="d64e727" src="../images/619782_1_En_7_Chapter/Imagem-079.jpg" style="width:35.15em"/><div class="TextObject" id="d64e727"><p class="Para" id="Par161">2 3-D diagrams of Docker containers. Container 1 has 3 layers, the bottom layer is the kernel, the middle layer is the Apache, emacs, Debian, and kernel, and the top layer is a writable layer. Container 2 has 2 layers, the bottom layer is the kernel, and the top layer is the writable layer.</p></div></div><figcaption class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Figure 7-8</span><p class="SimplePara">Docker container <span id="ITerm34">isolation</span></p></div></figcaption></figure></div>

          <div class="Para" id="Par58">When a container starts, the initial read-write layer is empty. As changes occur, they are applied to this <span id="ITerm35">read-write layer</span>, as shown in Figure <span class="InternalRef"><a href="#Fig9">7-9</a></span>.<figure class="Figure" id="Fig9"><div class="MediaObject" id="MO9"><img alt="" aria-describedby="d64e761" src="../images/619782_1_En_7_Chapter/Imagem-080.jpg" style="width:33.4em"/><div class="TextObject" id="d64e761"><p class="Para" id="Par162">A 3-D diagram of a container with layers. The top layer is labeled the writable layer. Below that are layers labeled Apache, emacs, and Debian. Below those layers are layers labeled c groups, namespaces, device mappers, Kernel, and boot f s.</p></div></div><figcaption class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Figure 7-9</span><p class="SimplePara">Docker container write <span id="ITerm36">layer</span></p></div></figcaption></figure></div>

          <div class="Para" id="Par59">To make it clear, if you want to change a file, that file will be copied from the read-only layer below into the read-write layer. The read-only version of the file will still exist, but it will be hidden underneath the copy by the overlays above it. See Figure <span class="InternalRef"><a href="#Fig10">7-10</a></span>.<figure class="Figure" id="Fig10"><div class="MediaObject" id="MO10"><img alt="" aria-describedby="d64e786" src="../images/619782_1_En_7_Chapter/Imagem-081.jpg" style="width:35.15em"/><div class="TextObject" id="d64e786"><p class="Para" id="Par163">An array diagram of a container. The layers are stacked on top of each other. From the bottom, the base layer, layer 1, layer 2, layer 3, and the write layer, which is layer 4. Each layer contains files A, B, C, D, and E. A dotted double-headed arrow connects file D in the base layer to file D in layer 3.</p></div></div><figcaption class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Figure 7-10</span><p class="SimplePara">The process of a Docker container <span id="ITerm37">write</span></p></div></figcaption></figure></div>

          <div class="Para" id="Par60">Each container can apply its own changes to its container read-write layer because they are isolated. See Figure <span class="InternalRef"><a href="#Fig11">7-11</a></span>.<figure class="Figure" id="Fig11"><div class="MediaObject" id="MO11"><img alt="" aria-describedby="d64e803" src="../images/619782_1_En_7_Chapter/Imagem-082.jpg" style="width:35.15em"/><div class="TextObject" id="d64e803"><p class="Para" id="Par164">A process diagram defines the process of a docker container copy on write. Containers 1, 2, and 3 have a read-write layer. The containers are stacked on top of each other, with the base layer at the bottom. The base layer is read-only, and each container can apply its changes to its container read-write layer.</p></div></div><figcaption class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Figure 7-11</span><p class="SimplePara">The process of a Docker container copy on write</p></div></figcaption></figure></div>

          <div class="Para" id="Par61">This pattern is traditionally called “copy on write” and is one of the features that makes Docker so powerful. Each read-only image layer is read-only—these images never change. When a container is created, Docker builds from the stack of images and adds the read-write layer on top. Figure <span class="InternalRef"><a href="#Fig11">7-11</a></span> shows the process of adding data to a container. Once you make your changes and commit them using Docker, Docker creates a new image. This image contains only the differences from the base. When you want to run this new image, you can make changes to that container, as represented in Figure <span class="InternalRef"><a href="#Fig12">7-12</a></span>.<figure class="Figure" id="Fig12"><div class="MediaObject" id="MO12"><img alt="" aria-describedby="d64e831" src="../images/619782_1_En_7_Chapter/Imagem-083.jpg" style="width:35.15em"/><div class="TextObject" id="d64e831"><p class="Para" id="Par165">A process diagram of a container Y with layers stacked on top of each other. From the bottom, the base layer, layer 1, layer 2, layer 3, and layer 4, and the write layer, which is layer 5. Each has layer I D, metadata, data, and a parent. base layer to layer 3 creates image X and base to layer 4 create image Y.</p></div></div><figcaption class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Figure 7-12</span><p class="SimplePara">The process of a Docker container <span id="ITerm38">commit</span></p></div></figcaption></figure></div>

        </section>

        <section class="Section2 RenderAsSection2" id="Sec13">

          <h3 class="Heading">Docker Registry</h3>

          <div class="Para" id="Par62">The Docker <span id="ITerm39">Registry</span> is a repository that stores your Docker images (see Figure <span class="InternalRef"><a href="#Fig13">7-13</a></span>). It can be private or public, and it can be local or remote. A Docker Registry facilitates easy sharing of Docker images between different development environments and runtimes. Once you have built your image, you can either run it on the computer you’ve built it on, or you can push (upload) the image to a registry and subsequently pull (download) it to the same computer or to another computer and run it there.<figure class="Figure" id="Fig13"><div class="MediaObject" id="MO13"><img alt="" aria-describedby="d64e858" src="../images/619782_1_En_7_Chapter/Imagem-084.jpg" style="width:35.15em"/><div class="TextObject" id="d64e858"><p class="Para" id="Par166">A flow diagram of docker images from a developer network to a production environment. The developer network pulls and pushes images to a docker public registry and a docker private registry in an internet cloud. Dev machine, staging, and production environments pull from the docker private registry.</p></div></div><figcaption class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Figure 7-13</span><p class="SimplePara">The Docker Registry</p></div></figcaption></figure></div>

          <p class="Para" id="Par63">Docker Hub is an example of a public registry. Private registries can be set up using many methods, like a private Docker Registry on JFrog Bintray. There are also remote repositories, which serve as caching proxies for a Docker Registry managed at a remote site such as Docker Hub or JFrog Bintray. Images are stored and updated in remote Docker Registries according to various configuration parameters that control the caching and proxying behavior.</p>

          <p class="Para" id="Par64">Development environment tools like <span id="ITerm40">JFrog Artifactory</span> can act as intermediaries between developer machines and remote Docker Registries. Since they fully implement the Docker Registry API specification, they can act as proxies to any public or private Docker Registry such as Docker Hub, JFrog Bintray, or other private Docker Registries. When an image is first requested by a developer machine, it is downloaded, and while doing this, Artifactory can store it in a local cache. Upon receiving subsequent requests for the image, Artifactory conducts a smart checksum search for it, and if the image has already been downloaded and is available in the local cache, the locally cached copy is provided. In this manner, each image is only downloaded once and is locally available to all other developers in the organization. This not only reduces network traffic but also effectively screens you from any issues with the network and other remote Docker Registries, thus providing you with a consistent, reliable, and continuous access to (remote) Docker images.</p>

        </section>

      </section>

      <section class="Section1 RenderAsSection1" id="Sec14">

        <h2 class="Heading">Hello World Tomcat in Docker</h2>

        <p class="Para" id="Par65">I’m sure you’ve read enough theory, so this section helps you learn by doing things. You will learn to run a “Docker Hello <span id="ITerm41">World</span>” program in this section.</p>

        <p class="Para" id="Par66">I assume that you have Docker Daemon running on your host. If not, refer to Appendix E to set up a Docker Daemon on your Mac machine (without Docker Desktop). If you have Docker Desktop on any of the OSes on your machine, that will also do.</p>

        <section class="Section2 RenderAsSection2" id="Sec15">

          <h3 class="Heading">Run Tomcat Container</h3>

          <div class="Para" id="Par67">The first step is to start the <span id="ITerm42">Minikube</span><span id="ITerm43"></span> single-node Kubernetes cluster so that you have a Docker Daemon up (see Listing <span class="InternalRef"><a href="#PC1">7-1</a></span>). Refer to Appendix E for a quick reference to the container commands.<div class="ProgramCode" id="PC1"><div class="LineGroup"><div class="FixedLine">(base) binildass-MacBook-Pro:~ binil$ pwd</div><div class="FixedLine">/Users/binil</div><div class="FixedLine">(base) binildass-MacBook-Pro:~ binil$ minikube start</div><div class="FixedLine">  minikube v1.25.2 on Darwin 12.4</div><div class="FixedLine">...</div><div class="FixedLine">  Done! kubectl is now configured to use "minikube" cluster and "default" namespace by default</div><div class="FixedLine">(base) binildass-MacBook-Pro:~ binil$</div></div><div class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Listing 7-1</span><p class="SimplePara">Starting Minikube</p></div></div></div></div>

          <div class="Para" id="Par68">Next, set the Minikube environment variables in your work terminal as shown in Listing <span class="InternalRef"><a href="#PC2">7-2</a></span>.<div class="ProgramCode" id="PC2"><div class="LineGroup"><div class="FixedLine">(base) binildass-MacBook-Pro:~ binil$ eval $(minikube docker-env)</div><div class="FixedLine">(base) binildass-MacBook-Pro:~ binil$</div></div><div class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Listing 7-2</span><p class="SimplePara">Setting Minikube Environment in Terminal</p></div></div></div></div>

          <p class="Para" id="Par69">This points the Docker client toward Minikube’s Docker environment since you are using the Docker Daemon in the Minikube VM. This setup is used for most of the Docker examples in this book. The <span class="EmphasisFontCategoryNonProportional ">minikube docker-env</span> command returns a set of Bash environment variable exports to configure your local host environment to reuse the Docker Daemon inside the Minikube instance. Passing this output through <span class="EmphasisFontCategoryNonProportional ">eval</span> causes <span class="EmphasisFontCategoryNonProportional ">bash</span> to evaluate these exported variables and put them into effect. This will build the Docker image using Minikube’s Docker instance and then push the image to Minikube’s Docker Registry. It will also set up your deployment in Minikube to use this image. These variables will thus help your Docker CLI (where you write Docker commands) connect with the Docker Daemon in the VM created by the Minikube.</p>

          <p class="Para" id="Par70">Instead, if you are using Docker Daemon from the Docker Desktop or a similar installation, you don’t need to set up this environment configuration.</p>

          <div class="Para" id="Par71">To list all the containers you have on your system, either running or stopped, execute the <span class="EmphasisFontCategoryNonProportional ">docker ps</span> command shown in Listing <span class="InternalRef"><a href="#PC3">7-3</a></span>.<div class="ProgramCode" id="PC3"><div class="LineGroup"><div class="FixedLine">(base) binildass-MacBook-Pro:~ binil$ docker ps</div><div class="FixedLine">CONTAINER ID  IMAGE         COMMAND                   CREATED        STATUS        PORTS   NAMES</div><div class="FixedLine">24eea7cbd5b2  e1482a24335a  "/dashboard --insecu..."  5 minutes ago  Up 5 minutes          k8s_kubernetes-</div><div class="FixedLine">c091fe0efebc  6e38f40d628d  "/storage-provisioner"    5 minutes ago  Up 5 minutes          k8s_storage-</div><div class="FixedLine">...</div><div class="FixedLine">(base) binildass-MacBook-Pro:~ binil$ docker ps</div></div><div class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Listing 7-3</span><p class="SimplePara">Listing Docker Containers</p></div></div></div></div>

          <p class="Para" id="Par72">The Docker client will list a table containing container IDs (a unique ID that you can use to refer to the container in other commands), creation date, the command used to start a container, status, exposed ports, and a name. The name can be assigned by you or Docker can pick an arbitrary name.</p>

          <div class="Para" id="Par73">Next, you can run a container. To run a container, use this <span class="EmphasisFontCategoryNonProportional ">docker run</span> command:<div class="ProgramCode" id="PC4"><div class="LineGroup"><div class="FixedLine">docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</div></div></div></div>

          <div class="Para" id="Par74">Listing <span class="InternalRef"><a href="#PC5">7-4</a></span> shows the code to bring up a Tomcat container.<div class="ProgramCode" id="PC5"><div class="LineGroup"><div class="FixedLine">(base) binildass-MacBook-Pro:~ binil$ docker run -it -p 8080:8080 tomcat</div><div class="FixedLine">Unable to find image 'tomcat:latest' locally</div><div class="FixedLine">latest: Pulling from library/tomcat</div><div class="FixedLine">67e8aa6c8bbc: Downloading [========&gt;                                  ]  9.653MB/54.95MB</div><div class="FixedLine">627e6c1e1055: Download complete</div><div class="FixedLine">0670968926f6: Downloading [=====================================&gt;     ]  8.059MB/10.88MB</div><div class="FixedLine">5a8b0e20be4b: Downloading [==&gt;                                        ]  3.226MB/54.58MB</div><div class="FixedLine">7a93fb438607: Waiting</div><div class="FixedLine">400f1e54bef0: Waiting</div><div class="FixedLine">f0b65b53f1a4: Waiting</div><div class="FixedLine">dc9d1a029c69: Waiting</div><div class="FixedLine">42a9874765c5: Waiting</div><div class="FixedLine">52140cf8a5cf: Waiting</div></div><div class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Listing 7-4</span><p class="SimplePara">Tomcat Container Starting Up</p></div></div></div></div>

          <p class="Para" id="Par75">The <span class="EmphasisFontCategoryNonProportional ">stdin</span>, <span class="EmphasisFontCategoryNonProportional ">stdout</span>, and <span class="EmphasisFontCategoryNonProportional ">ttys</span> are related concepts and an understanding will help you. <span class="EmphasisFontCategoryNonProportional ">stdin</span> and <span class="EmphasisFontCategoryNonProportional ">stdout</span> are the input and output streams of a process. A pseudo-terminal (also known as a <span class="EmphasisFontCategoryNonProportional ">tty</span> or a <span class="EmphasisFontCategoryNonProportional ">pts</span>) connects a user’s “terminal” with the <span class="EmphasisFontCategoryNonProportional ">stdin</span> and <span class="EmphasisFontCategoryNonProportional ">stdout</span> stream, commonly (but not necessarily) through a shell such as <span class="EmphasisFontCategoryNonProportional ">bash</span>. The word “terminal” is used in quotes since we really don’t use a terminal in the same sense today.</p>

          <p class="Para" id="Par76">As seen in Listing <span class="InternalRef"><a href="#PC5">7-4</a></span>, you’ll often use <span class="EmphasisFontCategoryNonProportional ">-t</span> and <span class="EmphasisFontCategoryNonProportional ">-i</span> together when you run processes in interactive mode, such as when starting a bash shell. In the case of the shell, your intention is to issue commands and read the output.</p>

          <p class="Para" id="Par77">In Docker, the <span class="EmphasisFontCategoryNonProportional ">-i</span> or <span class="EmphasisFontCategoryNonProportional ">--interactive</span> (for keeping STDIN stream open, even if not attached) and <span class="EmphasisFontCategoryNonProportional ">-t</span> or <span class="EmphasisFontCategoryNonProportional ">-tty</span> (for attaching a pseudo-<span class="EmphasisFontCategoryNonProportional ">tty</span>) switches are commonly used together as <span class="EmphasisFontCategoryNonProportional ">-it</span>, which will help you allocate a pseudo <span class="EmphasisFontCategoryNonProportional ">-tty</span> console for the process running in the container.</p>

          <p class="Para" id="Par78">The <span class="EmphasisFontCategoryNonProportional ">-it</span> combination will attach the command line to the container after it starts. This way you can see what’s going on in the running container in your shell console and interact with the container, if needed.</p>

          <div class="Para" id="Par79">When the command in Listing <span class="InternalRef"><a href="#PC5">7-4</a></span> is executed, Docker will determine if the image is available on your local machine. If it’s not, the image will be pulled from the remote repository. The Docker engine uses the image and adds a writable layer on top of the image’s layers stack. Subsequently, it initializes the image’s name, ID, and resource limits, such as CPU and memory. In this phase, Docker will also set up the container’s IP address by finding and attaching an available IP address from an IP pool. The last step of the execution is the actual command, passed as the last parameter of the <span class="EmphasisFontCategoryNonProportional ">docker run</span> command. See Listing <span class="InternalRef"><a href="#PC6">7-5</a></span>.<div class="ProgramCode" id="PC6"><div class="LineGroup"><div class="FixedLine">(base) binildass-MacBook-Pro:~ binil$ docker run -it -p 8080:8080 tomcat</div><div class="FixedLine">Unable to find image 'tomcat:latest' locally</div><div class="FixedLine">latest: Pulling from library/tomcat</div><div class="FixedLine">67e8aa6c8bbc: Pull complete</div><div class="FixedLine">627e6c1e1055: Pull complete</div><div class="FixedLine">0670968926f6: Pull complete</div><div class="FixedLine">5a8b0e20be4b: Pull complete</div><div class="FixedLine">7a93fb438607: Pull complete</div><div class="FixedLine">400f1e54bef0: Pull complete</div><div class="FixedLine">f0b65b53f1a4: Pull complete</div><div class="FixedLine">dc9d1a029c69: Pull complete</div><div class="FixedLine">42a9874765c5: Pull complete</div><div class="FixedLine">52140cf8a5cf: Pull complete</div><div class="FixedLine">Digest: sha256:fe703c02e16ea7d3e8d7bdf5a0c03957f2d4a313cfa9ae44878a3ad12e633ccf</div><div class="FixedLine">Status: Downloaded newer image for tomcat:latest</div><div class="FixedLine">Using CATALINA_BASE:   /usr/local/tomcat</div><div class="FixedLine">Using CATALINA_HOME:   /usr/local/tomcat</div><div class="FixedLine">Using CATALINA_TMPDIR: /usr/local/tomcat/temp</div><div class="FixedLine">Using JRE_HOME:        /usr/local/openjdk-11</div><div class="FixedLine">Using CLASSPATH:       /usr/local/tomcat/bin/bootstrap.jar:/usr/local/tomcat/bin/tomcat-juli.jar</div><div class="FixedLine">Using CATALINA_OPTS:</div><div class="FixedLine">...</div><div class="FixedLine">26-May-2022 14:33:47.952 INFO [main] org.apache.catalina.startup.Catalina.start Server startup in [100] milliseconds</div></div><div class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Listing 7-5</span><p class="SimplePara">Tomcat Container Running</p></div></div></div></div>

          <p class="Para" id="Par80">Listing <span class="InternalRef"><a href="#PC6">7-5</a></span> shows a Tomcat container running. Since the <span class="EmphasisFontCategoryNonProportional ">-it</span> option has been used, Docker will capture and provide the container output, which is displayed in the console. When you run this command, Docker will install <span class="EmphasisFontCategoryNonProportional ">tomcat:latest</span> from the Tomcat public repository hosted on Docker Hub and run the software. After Docker has installed and started running Tomcat, one line of seemingly random characters will be written to the terminal. This blob of characters is a unique identifier of the container that was just created to run Tomcat. Every time you invoke the <span class="EmphasisFontCategoryNonProportional ">docker run</span> command and create a new container, that newly created container will get a unique identifier like this.</p>

          <div class="Para" id="Par81">You can now list the Docker containers again, as shown in Listing <span class="InternalRef"><a href="#PC7">7-6</a></span>.<div class="ProgramCode" id="PC7"><div class="LineGroup"><div class="FixedLine">(base) binildass-MacBook-Pro:~ binil$ docker ps</div><div class="FixedLine">CONTAINER ID  IMAGE   COMMAND  CREATED  STATUS  PORTS   NAMES</div><div class="FixedLine">5b621bcd9dd1  tomcat  "catalina.sh run"  About a minute ago   Up About a minute   0.0.0.0:8080-&gt;8080/tcp   priceless_chebyshev</div><div class="FixedLine">...</div><div class="FixedLine">(base) binildass-MacBook-Pro:~ binil$</div></div><div class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Listing 7-6</span><p class="SimplePara">Listing Docker Containers</p></div></div></div></div>

          <div class="Para" id="Par82">You can see the Tomcat container which you just started, along with other containers. To access Tomcat, as mentioned in Appendix E, you must get the minikube IP first. See Listing <span class="InternalRef"><a href="#PC8">7-7</a></span>.<div class="ProgramCode" id="PC8"><div class="LineGroup"><div class="FixedLine">(base) binildass-MacBook-Pro:ch07-01 binil$ minikube ip</div><div class="FixedLine">192.168.64.5</div><div class="FixedLine">(base) binildass-MacBook-Pro:ch07-01 binil$</div></div><div class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Listing 7-7</span><p class="SimplePara">Finding Minikube IP</p></div></div></div></div>

          <div class="Para" id="Par83">You can now access the Tomcat using the <span class="EmphasisFontCategoryNonProportional ">curl</span> command, as shown in Listing <span class="InternalRef"><a href="#PC9">7-8</a></span>.<div class="ProgramCode" id="PC9"><div class="LineGroup"><div class="FixedLine">(base) binildass-MacBook-Pro:ch07-01 binil$ curl http://192.168.64.5:8080</div><div class="FixedLine">HTTP Status 404 – Not Found...</div><div class="FixedLine">(base) binildass-MacBook-Pro:ch07-01 binil$</div></div><div class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Listing 7-8</span><p class="SimplePara">Accessing Tomcat Container</p></div></div></div></div>

          <div class="Para" id="Par84">You may also use a browser, as shown in Figure <span class="InternalRef"><a href="#Fig14">7-14</a></span>.<figure class="Figure" id="Fig14"><div class="MediaObject" id="MO14"><img alt="" aria-describedby="d64e1272" src="../images/619782_1_En_7_Chapter/Imagem-085.jpg" style="width:35.15em"/><div class="TextObject" id="d64e1272"><p class="Para" id="Par167">A screenshot of the web browser window featuring a 404 not found error message. The message is provided in bold text. The web address is 192.168.64.5. The browser is not secure.</p></div></div><figcaption class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Figure 7-14</span><p class="SimplePara">Accessing “No Web App” in a Tomcat container</p></div></figcaption></figure></div>

          <div class="Para" id="Par85">You might think that you made a mistake while installing the Docker image when you see the <span class="EmphasisFontCategoryNonProportional ">404</span> error. But this is not an error and it was designed to behave like this due to security concerns raised by the Docker community. You can find this security information on the Tomcat image official documentation in Docker Hub. See Figure <span class="InternalRef"><a href="#Fig15">7-15</a></span>.<figure class="Figure" id="Fig15"><div class="MediaObject" id="MO15"><img alt="" aria-describedby="d64e1292" src="../images/619782_1_En_7_Chapter/Imagem-086.jpg" style="width:35.15em"/><div class="TextObject" id="d64e1292"><p class="Para" id="Par168">A screenshot of a web page reads instructions on how to use the docker Tomcat image. It explains that web applications are not enabled by default for security reasons, and are available in a folder within the image, provides instructions on how to run the Tomcat server, and test it in a browser.</p></div></div><figcaption class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Figure 7-15</span><p class="SimplePara">Docker Tomcat notice</p></div></figcaption></figure></div>

          <div class="Para" id="Par86">You can stop the Tomcat container by using the code in Listing <span class="InternalRef"><a href="#PC10">7-9</a></span>.<div class="ProgramCode" id="PC10"><div class="LineGroup"><div class="FixedLine">(base) binildass-MacBook-Pro:~ binil$ docker stop 5b62</div><div class="FixedLine">5b62</div><div class="FixedLine">(base) binildass-MacBook-Pro:~ binil$</div></div><div class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Listing 7-9</span><p class="SimplePara">Stopping Tomcat Container</p></div></div></div></div>

          <div class="Para" id="Par87">Note that <span class="EmphasisFontCategoryNonProportional ">5b62</span> are the first four characters of the container ID in Listing <span class="InternalRef"><a href="#PC7">7-6</a></span>. This container, when stopped, will retain all settings and filesystem changes (in the top layer that is writeable). All processes running in the container will be stopped and you will lose everything in memory. If you now attempted to access the Tomcat using the <span class="EmphasisFontCategoryNonProportional ">curl</span> command, you would get the response shown in Listing <span class="InternalRef"><a href="#PC11">7-10</a></span>.<div class="ProgramCode" id="PC11"><div class="LineGroup"><div class="FixedLine">(base) binildass-MacBook-Pro:~ binil$ curl http://192.168.64.5:8080</div><div class="FixedLine">curl: (7) Failed to connect to 192.168.64.5 port 8080: Connection refused</div><div class="FixedLine">(base) binildass-MacBook-Pro:~ binil$</div></div><div class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Listing 7-10</span><p class="SimplePara">Attempt to Access Tomcat Container</p></div></div></div></div>

        </section>

      </section>

      <section class="Section1 RenderAsSection1" id="Sec16">

        <h2 class="Heading">Build and Run Java App without Java</h2>

        <p class="Para" id="Par88">The aim of this section is to compile, package, deploy, and run a Java app without a Java SDK or <span id="ITerm44">Java</span> runtime in your development machine. How do you do that? You might have already guessed, since you are learning to use Docker, right? Use <span id="ITerm45">Docker</span>!</p>

        <section class="Section2 RenderAsSection2" id="Sec17">

          <h3 class="Heading">Using a Maven Container</h3>

          <div class="Para" id="Par89">You can run the official Maven Docker image as a container and further compile, package, and deploy a Java application. Let’s see how to use that here. First, set the Minikube <span id="ITerm46">environment variables</span> in your terminal as mentioned in Listing <span class="InternalRef"><a href="#PC2">7-2</a></span>. Next, run Docker, as shown in Listing <span class="InternalRef"><a href="#PC12">7-11</a></span>.<div class="ProgramCode" id="PC12"><div class="LineGroup"><div class="FixedLine">(base) binildass-MacBook-Pro:~ binil$ docker run --rm -it maven mvn --version</div><div class="FixedLine">Unable to find image 'maven:latest' locally</div><div class="FixedLine">latest: Pulling from library/maven</div><div class="FixedLine">d5fd17ec1767: Pull complete</div><div class="FixedLine">...</div><div class="FixedLine">Status: Downloaded newer image for maven:latest</div><div class="FixedLine">Apache Maven 3.8.5 (3599d3414f046de2324203b78ddcf9b5e4388aa0)</div><div class="FixedLine">Maven home: /usr/share/maven</div><div class="FixedLine">Java version: 17.0.3, vendor: Eclipse Adoptium, runtime: /opt/java/openjdk</div><div class="FixedLine">Default locale: en_US, platform encoding: UTF-8</div><div class="FixedLine">OS name: "linux", version: "4.19.202", arch: "amd64", family: "unix"</div><div class="FixedLine">(base) binildass-MacBook-Pro:~ binil$</div></div><div class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Listing 7-11</span><p class="SimplePara">Running Maven Container</p></div></div></div></div>

          <p class="Para" id="Par90">Listing <span class="InternalRef"><a href="#PC12">7-11</a></span> creates a Maven container and runs the <span class="EmphasisFontCategoryNonProportional ">maven</span> command in it. The <span class="EmphasisFontCategoryNonProportional ">--rm</span> parameter will remove the container once the command has been completed.</p>

        </section>

        <section class="Section2 RenderAsSection2" id="Sec18">

          <h3 class="Heading">Creating a Maven Archetype</h3>

          <div class="Para" id="Par91">In this section, you create a new web application project Product Web of type <span class="EmphasisFontCategoryNonProportional ">maven-</span><span id="ITerm47"><span class="EmphasisFontCategoryNonProportional ">archetype-webapp</span></span>. See Listing <span class="InternalRef"><a href="#PC13">7-12</a></span>.<div class="ProgramCode" id="PC13"><div class="LineGroup"><div class="FixedLine">(base) binildass-MacBook-Pro:~ binil$ docker run --rm -it -v $(pwd):/workfolder -w /workfolder maven mvn archetype:generate -DgroupId=com.acme.ecom.product -DartifactId=ProductWeb -DarchetypeArtifactId=maven-archetype-webapp -DinteractiveMode=false</div><div class="FixedLine">[INFO] Scanning for projects...</div><div class="FixedLine">Downloaded from central: ...</div><div class="FixedLine">...</div><div class="FixedLine">[INFO] ---------------------------------------------------</div><div class="FixedLine">[INFO] Using following parameters for creating project from Old (1.x) Archetype: maven-archetype-webapp:1.0</div><div class="FixedLine">[INFO] ---------------------------------------------------</div><div class="FixedLine">[INFO] Parameter: basedir, Value: /workfolder</div><div class="FixedLine">[INFO] Parameter: package, Value: com.acme.ecom.product</div><div class="FixedLine">[INFO] Parameter: groupId, Value: com.acme.ecom.product</div><div class="FixedLine">[INFO] Parameter: artifactId, Value: ProductWeb</div><div class="FixedLine">[INFO] Parameter: packageName, Value: com.acme.ecom.product</div><div class="FixedLine">[INFO] Parameter: version, Value: 1.0-SNAPSHOT</div><div class="FixedLine">[INFO] project created from Old (1.x) Archetype in dir: /workfolder/ProductWeb</div><div class="FixedLine">[INFO] ---------------------------------------------------</div><div class="FixedLine">[INFO] BUILD SUCCESS</div><div class="FixedLine">[INFO] ----------------------------------------------------</div><div class="FixedLine">[INFO] Total time:  02:02 min</div><div class="FixedLine">[INFO] Finished at: 2022-05-26T14:53:54Z</div><div class="FixedLine">[INFO] ---------------------------------------------------</div><div class="FixedLine">(base) binildass-MacBook-Pro:~ binil$</div></div><div class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Listing 7-12</span><p class="SimplePara">Creating maven-archetype-webapp with the Maven Container</p></div></div></div></div>

          <p class="Para" id="Par92"><span class="EmphasisFontCategoryNonProportional ">-v $(pwd):/workfolder</span> mounts the current directory as <span class="EmphasisFontCategoryNonProportional ">/workfolder</span> in the container. <span class="EmphasisFontCategoryNonProportional ">-w /workfolder</span> changes the current working directory for the container to <span class="EmphasisFontCategoryNonProportional ">/workfolder</span>. When you run the <span class="EmphasisFontCategoryNonProportional ">-DartifactId= ProductWeb</span> command, you will have a new project with a new directory called <span class="EmphasisFontCategoryNonProportional ">ProductWeb</span>, which is created in the mounted volume. It’s preserved after you destroy the container, since the mounted directory is not within the container but actually refers to a folder in the host machine.</p>

          <div class="Para" id="Par93">There is a catch here. If you are using Docker Desktop or a similar Docker Daemon, you will find the newly project created in the <span class="EmphasisFontCategoryNonProportional ">ProductWeb</span> folder in the host machine. However, this example uses a Docker Daemon inside Minikube, so to see the newly created project, you need to look inside the virtual machine hosting minikube. See Listing <span class="InternalRef"><a href="#PC14">7-13</a></span>.<div class="ProgramCode" id="PC14"><div class="LineGroup"><div class="FixedLine">(base) binildass-MacBook-Pro:~ binil$ pwd</div><div class="FixedLine">/Users/binil</div><div class="FixedLine">(base) binildass-MacBook-Pro:~ binil$ minikube ssh</div><div class="FixedLine">                         _             _</div><div class="FixedLine">            _         _ ( )           ( )</div><div class="FixedLine">  ___ ___  (_)  ___  (_)| |/')  _   _ | |_      __</div><div class="FixedLine">/' _ ` _ `\| |/' _ `\| || , &lt;  ( ) ( )| '_`\  /'__`\</div><div class="FixedLine">| ( ) ( ) || || ( ) || || |\`\ | (_) || |_) )(  ___/</div><div class="FixedLine">(_) (_) (_)(_)(_) (_)(_)(_) (_)`\___/'(_,__/'`\____)</div></div><div class="LineGroup"><div class="FixedLine">$ cd /Users/binil/binil/code/mac/mybooks/docker-03/ch07/ch07-01</div><div class="FixedLine">$ ls</div><div class="FixedLine">ProductWeb</div><div class="FixedLine">$ cd ProductWeb/</div><div class="FixedLine">$ ls</div><div class="FixedLine">pom.xml  src</div><div class="FixedLine">$</div></div><div class="LineGroup"><div class="FixedLine">(base) binildass-MacBook-Pro:~ binil$ tree ProductWeb/</div><div class="FixedLine">ProductWeb/</div><div class="FixedLine">├── pom.xml</div><div class="FixedLine">└── src</div><div class="FixedLine">    └── main</div><div class="FixedLine">        ├── resources</div><div class="FixedLine">        └── webapp</div><div class="FixedLine">            ├── WEB-INF</div><div class="FixedLine">            │   └── web.xml</div><div class="FixedLine">            └── index.jsp</div></div><div class="LineGroup"><div class="FixedLine">5 directories, 3 files</div><div class="FixedLine">(base) binildass-MacBook-Pro:~ binil$</div></div><div class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Listing 7-13</span><p class="SimplePara">Log in to Minikube VM</p></div></div></div></div>

          <p class="Para" id="Par94">Inside the Minikube host, this is inside the <span class="EmphasisFontCategoryNonProportional ">/Users/binil/binil/code/mac/mybooks/docker-03/ch07/ch07-01</span> folder, since that’s where the current working folder is (assuming that is your working folder). You might have to tweak it according to the path in your machine, since this example can be built and run from any folder.</p>

        </section>

        <section class="Section2 RenderAsSection2" id="Sec19">

          <h3 class="Heading">Build and Package Using Maven Container</h3>

          <div class="Para" id="Par95">Here, you don’t make any changes to the Maven web app project. You see how to build and <span id="ITerm48">package</span> it. In a terminal where you set the Minikube environment variables, as mentioned in Listing <span class="InternalRef"><a href="#PC2">7-2</a></span>, you can run Docker again, as shown in Listing <span class="InternalRef"><a href="#PC15">7-14</a></span>.<div class="ProgramCode" id="PC15"><div class="LineGroup"><div class="FixedLine">(base) binildass-MacBook-Pro:~ binil$ docker run --rm -it -v $(pwd)/ProductWeb:/DockerHostProductWeb -w /DockerHostProductWeb maven:3.8.5-jdk-11 mvn clean package</div><div class="FixedLine">[INFO] Scanning for projects...</div><div class="FixedLine">[INFO]</div><div class="FixedLine">[INFO] ---------&lt; com.acme.ecom.product:ProductWeb01 &gt;----</div><div class="FixedLine">[INFO] Building ProductWeb Maven Webapp 1.0-SNAPSHOT</div><div class="FixedLine">[INFO] --------------------------------[ war ]------------</div><div class="FixedLine">Downloading from central: https://repo.maven.apache.org/maven2/...</div><div class="FixedLine">...</div><div class="FixedLine">[INFO] Packaging webapp</div><div class="FixedLine">[INFO] Assembling webapp [ProductWeb01] in [/DockerHostProductWeb/target/ProductWeb]</div><div class="FixedLine">[INFO] Processing war project</div><div class="FixedLine">[INFO] Copying webapp resources [/DockerHostProductWeb/src/main/webapp]</div><div class="FixedLine">[INFO] Webapp assembled in [13 msecs]</div><div class="FixedLine">[INFO] Building war: /DockerHostProductWeb/target/ProductWeb.war</div><div class="FixedLine">[INFO] WEB-INF/web.xml already added, skipping</div><div class="FixedLine">[INFO] ---------------------------------------------------</div><div class="FixedLine">[INFO] BUILD SUCCESS</div><div class="FixedLine">[INFO] --------------------------------------------------</div><div class="FixedLine">[INFO] Total time:  02:07 min</div><div class="FixedLine">[INFO] Finished at: 2022-05-26T17:17:19Z</div><div class="FixedLine">[INFO] --------------------------------------------------</div><div class="FixedLine">(base) binildass-MacBook-Pro:~ binil$</div></div><div class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Listing 7-14</span><p class="SimplePara">Build and Package Web App Using Maven Container</p></div></div></div></div>

          <div class="Para" id="Par96">Here, <span class="EmphasisFontCategoryNonProportional ">-v $(pwd)/ProductWeb:/DockerHostProductWeb</span> will mount the <span class="EmphasisFontCategoryNonProportional ">/Users/binil/binil/code/mac/mybooks/docker-03/ch07/ch07-01/ProductWeb</span> path as <span class="EmphasisFontCategoryNonProportional ">DockerHostProductWeb</span> for the container. <span class="EmphasisFontCategoryNonProportional ">-w /DockerHostProductWeb</span> will set <span class="EmphasisFontCategoryNonProportional ">DockerHostProductWeb</span> as the current working directory, and the Maven container executes the command. The command will create a directory called <span class="EmphasisFontCategoryNonProportional ">target</span> in the location of your project (inside <span class="EmphasisFontCategoryNonProportional ">/Users/binil/binil/code/mac/mybooks/docker-03/ch07/ch07-01/ProductWeb</span> in Minikube VM) and it should contain your build. Since you set the artifact ID to be <span class="EmphasisFontCategoryNonProportional ">ProductWeb</span>, it should look something like Listing <span class="InternalRef"><a href="#PC16">7-15</a></span>.<div class="ProgramCode" id="PC16"><div class="LineGroup"><div class="FixedLine">(base) binildass-MacBook-Pro:~ binil$ tree ProductWeb/</div><div class="FixedLine">ProductWeb/</div><div class="FixedLine">├── pom.xml</div><div class="FixedLine">├── src</div><div class="FixedLine">│   └── main</div><div class="FixedLine">│       ├── resources</div><div class="FixedLine">│       └── webapp</div><div class="FixedLine">│           ├── WEB-INF</div><div class="FixedLine">│           │   └── web.xml</div><div class="FixedLine">│           └── index.jsp</div><div class="FixedLine">└── target</div><div class="FixedLine">    ├── ProductWeb</div><div class="FixedLine">    │   ├── META-INF</div><div class="FixedLine">    │   ├── WEB-INF</div><div class="FixedLine">    │   │   ├── classes</div><div class="FixedLine">    │   │   └── web.xml</div><div class="FixedLine">    │   └── index.jsp</div><div class="FixedLine">    ├── ProductWeb.war</div><div class="FixedLine">    ├── classes</div><div class="FixedLine">    └── maven-archiver</div><div class="FixedLine">        └── pom.properties</div></div><div class="LineGroup"><div class="FixedLine">12 directories, 7 files</div><div class="FixedLine">(base) binildass-MacBook-Pro:~ binil$</div></div><div class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Listing 7-15</span><p class="SimplePara">Web App Project Folder Exploded After Build</p></div></div></div></div>

        </section>

        <section class="Section2 RenderAsSection2" id="Sec20">

          <h3 class="Heading">Deploy Webapp Using Maven Container</h3>

          <div class="Para" id="Par97">You can simply add your application build to Tomcat’s <span class="EmphasisFontCategoryNonProportional ">webapps</span> <span id="ITerm49">directory</span> (in the case of the official Docker image, that is <span class="EmphasisFontCategoryNonProportional ">/usr/local/tomcat/webapps</span>) to deploy your app. Based on the build name added to the <span class="EmphasisFontCategoryNonProportional ">webapps</span> directory, Tomcat maps this application to a specific route. If you were to add <span class="EmphasisFontCategoryNonProportional ">ProductWeb.war</span> to <span class="EmphasisFontCategoryNonProportional ">webapps</span> as <span class="EmphasisFontCategoryNonProportional ">product-web.war</span>, you could access it on <span class="EmphasisFontCategoryNonProportional ">/product-web</span> path for the Tomcat URL. If you want to deploy your application without any extra paths, you have to use an artefact named <span class="EmphasisFontCategoryNonProportional ">ROOT</span>. See Listing <span class="InternalRef"><a href="#PC17">7-16</a></span>.<div class="ProgramCode" id="PC17"><div class="LineGroup"><div class="FixedLine">(base) binildass-MacBook-Pro:~ binil$ docker run -it -p 8080:8080 -v $(pwd)/ProductWeb/target/ProductWeb.war:/usr/local/tomcat/webapps/productapp.war tomcat</div><div class="FixedLine">Using CATALINA_BASE:   /usr/local/tomcat</div><div class="FixedLine">Using CATALINA_HOME:   /usr/local/tomcat</div><div class="FixedLine">Using CATALINA_TMPDIR: /usr/local/tomcat/temp</div><div class="FixedLine">Using JRE_HOME:        /usr/local/openjdk-11</div><div class="FixedLine">Using CLASSPATH:       /usr/local/tomcat/bin/bootstrap.jar:/usr/local/tomcat/bin/tomcat-juli.jar</div><div class="FixedLine">Using CATALINA_OPTS:</div><div class="FixedLine">...</div><div class="FixedLine">26-May-2022 17:41:34.052 INFO [main] org.apache.catalina.startup.HostConfig.deployWAR Deploying web application archive [/usr/local/tomcat/webapps/productapp.war]</div><div class="FixedLine">26-May-2022 17:41:34.307 INFO [main] org.apache.catalina.startup.HostConfig.deployWAR Deployment of web application archive [/usr/local/tomcat/webapps/productapp.war] has finished in [255] ms</div><div class="FixedLine">26-May-2022 17:41:34.310 INFO [main] org.apache.coyote.AbstractProtocol.start Starting ProtocolHandler ["http-nio-8080"]</div><div class="FixedLine">26-May-2022 17:41:34.329 INFO [main] org.apache.catalina.startup.Catalina.start Server startup in [339] milliseconds</div></div><div class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Listing 7-16</span><p class="SimplePara">Deploy Web App Project Using Maven Container</p></div></div></div></div>

          <div class="Para" id="Par98">In the previous section, you saw how to run a Tomcat container. Let’s repeat that here again as in Listing <span class="InternalRef"><a href="#PC17">7-16</a></span>. Note that the Tomcat image is not downloaded this time, since it’s already downloaded, as in Listing <span class="InternalRef"><a href="#PC6">7-5</a></span>. You can go to <span class="EmphasisFontCategoryNonProportional ">/productapp</span> on port 8080 for your Docker environment and see the output of your web application using a browser, as shown in Figure <span class="InternalRef"><a href="#Fig16">7-16</a></span>.<figure class="Figure" id="Fig16"><div class="MediaObject" id="MO16"><img alt="" aria-describedby="d64e1848" src="../images/619782_1_En_7_Chapter/Imagem-087.jpg" style="width:35.15em"/><div class="TextObject" id="d64e1848"><p class="Para" id="Par169">A screenshot of a web browser window featuring a 404 error message. The text Hello World is given on the page.</p></div></div><figcaption class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Figure 7-16</span><p class="SimplePara">Access a web app in the Tomcat container</p></div></figcaption></figure></div>

          <div class="Para" id="Par99">Note that 192.168.64.5 is the IP for the Minikube. You can also access the application using cURL, as in Listing <span class="InternalRef"><a href="#PC18">7-17</a></span>.<div class="ProgramCode" id="PC18"><div class="LineGroup"><div class="FixedLine">(base) binildass-MacBook-Pro:~ binil$ curl http://192.168.64.5:8080/productapp/</div><div class="FixedLine">&lt;html&gt;</div><div class="FixedLine">&lt;body&gt;</div><div class="FixedLine">&lt;h2&gt;Hello World!&lt;/h2&gt;</div><div class="FixedLine">&lt;/body&gt;</div><div class="FixedLine">&lt;/html&gt;</div><div class="FixedLine">(base) binildass-MacBook-Pro:~ binil$</div></div><div class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Listing 7-17</span><p class="SimplePara">Access Web App in Tomcat Using cURL</p></div></div></div></div>

          <div class="Para" id="Par100">Once that’s done, you can stop the Tomcat container using the code in Listing <span class="InternalRef"><a href="#PC19">7-18</a></span>.<div class="ProgramCode" id="PC19"><div class="LineGroup"><div class="FixedLine">(base) binildass-MacBook-Pro:~ binil$ docker ps</div><div class="FixedLine">CONTAINER ID   IMAGE    COMMAND             CREATED         STATUS         PORTS                           NAMES</div><div class="FixedLine">a198aabd9464   tomcat  "catalina.sh run"   8 minutes ago   Up 8 minutes   0.0.0.0:8080-&gt;8080/tcp   happy_gould</div><div class="FixedLine">..</div><div class="FixedLine">(base) binildass-MacBook-Pro:~ binil$ docker stop a198</div><div class="FixedLine">a198</div><div class="FixedLine">(base) binildass-MacBook-Pro:~ binil$</div></div><div class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Listing 7-18</span><p class="SimplePara">Stopping Tomcat Container</p></div></div></div></div>

          <p class="Para" id="Par101">That was a simple example to demonstrate how you can build, package, deploy, and run a Java application without even having Java installed on your host machine! The next section moves to the next concept—Docker Compose.</p>

        </section>

      </section>

      <section class="Section1 RenderAsSection1" id="Sec21">

        <h2 class="Heading">Build and Run Java App with Docker Compose</h2>

        <p class="Para" id="Par102">The objective here is to compile, package, deploy, and run a Java <span id="ITerm50">app</span> using Docker <span id="ITerm51">Compose</span>. I include more details and examples of Docker Compose in a later chapter. Let’s just run this example for the completion of our discussion.</p>

        <section class="Section2 RenderAsSection2" id="Sec22">

          <h3 class="Heading">Using Docker Compose</h3>

          <div class="Para" id="Par103">The source code for this book is available on GitHub via the book’s product page, located at <span class="ExternalRef"><a href="http://www.apress.com/9798868805547"><span class="RefSource"><span class="EmphasisFontCategoryNonProportional ">www.apress.com/9798868805547</span></span></a></span>. The code for this example is organized inside the <span class="EmphasisFontCategoryNonProportional ">ch07\ch07-01</span> folder. Refer to Appendix E on Docker to make sure you have installed Docker Compose. Docker Compose uses the file shown in Listing <span class="InternalRef"><a href="#PC20">7-19</a></span>.<div class="ProgramCode" id="PC20"><div class="LineGroup"><div class="FixedLine">version: '2'</div><div class="FixedLine">services:</div><div class="FixedLine">    web:</div><div class="FixedLine">        image: tomcat</div><div class="FixedLine">        ports:</div><div class="FixedLine">            - "8080:8080"</div><div class="FixedLine">        volumes:</div><div class="FixedLine">            - ./ProductWeb/target/ProductWeb.war:</div><div class="FixedLine">                 /usr/local/tomcat/webapps/ROOT.war</div><div class="FixedLine">            - ./ProductWeb/target/ProductWeb:</div><div class="FixedLine">                 /usr/local/tomcat/webapps/ROOT</div></div><div class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Listing 7-19</span><p class="SimplePara">Docker Compose YML File</p></div></div></div></div>

          <div class="Para" id="Par104">If you want to deploy your application without any extra paths, you have to place an artifact named <span class="EmphasisFontCategoryNonProportional ">ROOT</span>. That is done by the directory mounting in Listing <span class="InternalRef"><a href="#PC20">7-19</a></span>. Then you run Docker to package, as in an earlier example, and subsequently <span class="EmphasisFontCategoryNonProportional ">run docker-compose</span>, both commands in one go. <span class="EmphasisFontCategoryNonProportional ">docker-compose</span> will fetch the <span class="EmphasisFontCategoryNonProportional ">docker-compose.yml</span>, as shown in Listing <span class="InternalRef"><a href="#PC21">7-20</a></span>.<div class="ProgramCode" id="PC21"><div class="LineGroup"><div class="FixedLine">(base) binildass-MacBook-Pro:ch07-01 binil$ docker run --rm -it -v $(pwd)/ProductWeb:/ProductWebDockerHost -w /ProductWebDockerHost maven:3.8.5-jdk-11 mvn package &amp;&amp; docker-compose up</div><div class="FixedLine">[INFO] Scanning for projects...</div><div class="FixedLine">[INFO]</div><div class="FixedLine">[INFO] ------&lt; com.acme.ecom.product:ProductWeb &gt;--------</div></div><div class="LineGroup"><div class="FixedLine">WARNING: All illegal access operations will be denied in a future release</div><div class="FixedLine">[INFO] Packaging webapp</div><div class="FixedLine">[INFO] Assembling webapp [ProductWeb] in [/ProductWebDockerHost/target/ProductWeb]</div><div class="FixedLine">[INFO] Processing war project</div><div class="FixedLine">[INFO] Copying webapp resources [/ProductWebDockerHost/src/main/webapp]</div><div class="FixedLine">[INFO] Webapp assembled in [16 msecs]</div><div class="FixedLine">[INFO] Building war: /ProductWebDockerHost/target/ProductWeb.war</div><div class="FixedLine">[INFO] WEB-INF/web.xml already added, skipping</div><div class="FixedLine">[INFO] -------------------------------------------------</div><div class="FixedLine">[INFO] BUILD SUCCESS</div><div class="FixedLine">[INFO] --------------------------------------------------</div><div class="FixedLine">[INFO] Total time:  01:56 min</div><div class="FixedLine">[INFO] Finished at: 2022-05-26T18:04:38Z</div><div class="FixedLine">[INFO] ---------------------------------------------------</div><div class="FixedLine">[+] Running 2/0</div><div class="FixedLine"> ⠿ Network ch07-01_default  Created                  0.1s</div><div class="FixedLine"> ⠿ Container ch07-01-web-1  Created                  0.0s</div><div class="FixedLine">Attaching to ch07-01-web-1</div><div class="FixedLine">...</div><div class="FixedLine">ch07-01-web-1  | 26-May-2022 18:04:40.683 INFO [main] org.apache.catalina.startup.HostConfig.deployWAR Deploying web application archive [/usr/local/tomcat/webapps/ROOT.war]</div><div class="FixedLine">ch07-01-web-1  | 26-May-2022 18:04:41.016 INFO [main] org.apache.catalina.startup.HostConfig.deployWAR Deployment of web application archive [/usr/local/tomcat/webapps/ROOT.war] has finished in [333] ms</div><div class="FixedLine">ch07-01-web-1  | 26-May-2022 18:04:41.020 INFO [main] org.apache.coyote.AbstractProtocol.start Starting ProtocolHandler ["http-nio-8080"]</div><div class="FixedLine">ch07-01-web-1  | 26-May-2022 18:04:41.054 INFO [main] org.apache.catalina.startup.Catalina.start Server startup in [465] milliseconds</div></div><div class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Listing 7-20</span><p class="SimplePara">Run Tomcat Container using Docker Compose</p></div></div></div></div>

          <div class="Para" id="Par105">Next, access the application <span class="EmphasisFontCategoryNonProportional ">http://192.168.64.5:8080</span>. See Figure <span class="InternalRef"><a href="#Fig17">7-17</a></span>.<figure class="Figure" id="Fig17"><div class="MediaObject" id="MO17"><img alt="" aria-describedby="d64e2076" src="../images/619782_1_En_7_Chapter/Imagem-088.jpg" style="width:35.15em"/><div class="TextObject" id="d64e2076"><p class="Para" id="Par170">A screenshot of a web browser window featuring a 404 error message. The text Hello World is given on the page.</p></div></div><figcaption class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Figure 7-17</span><p class="SimplePara">Access the web app in a Tomcat container</p></div></figcaption></figure></div>

          <div class="Para" id="Par106">You can also access the application using cURL, as shown in Listing <span class="InternalRef"><a href="#PC22">7-21</a></span>.<div class="ProgramCode" id="PC22"><div class="LineGroup"><div class="FixedLine">(base) binildass-MacBook-Pro:ch07-01 binil$ curl http://192.168.64.5:8080/</div><div class="FixedLine">&lt;html&gt;</div><div class="FixedLine">&lt;body&gt;</div><div class="FixedLine">&lt;h2&gt;Hello World!&lt;/h2&gt;</div><div class="FixedLine">&lt;/body&gt;</div><div class="FixedLine">&lt;/html&gt;</div><div class="FixedLine">(base) binildass-MacBook-Pro:ch07-01 binil$</div></div><div class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Listing 7-21</span><p class="SimplePara">Access Web App in Tomcat Container Using cURL</p></div></div></div></div>

        </section>

      </section>

      <section class="Section1 RenderAsSection1" id="Sec23">

        <h2 class="Heading">Build the First Java Microservice with Docker</h2>

        <p class="Para" id="Par107">In this section, you investigate using Docker to deploy a more serious microservice. For that, you use the same microservice deployed in the section titled “Your First <span id="ITerm52">Java</span> Microservice” in Chapter <span class="ExternalRef"><a href="Capítulo-03.html"><span class="RefSource">1</span></a></span>.</p>

        <section class="Section2 RenderAsSection2" id="Sec24">

          <h3 class="Heading">Dockerizing the Microservice Using Jib</h3>

          <p class="Para" id="Par108"><span id="ITerm53">Jib</span> is an open-source Java tool maintained by Google for building Docker images of Java-based applications. Jib simplifies containerization, since with it, you don’t need to write a Dockerfile (you will learn what a Dockerfile is in the next section), which you saw in the previous example. Moreover, you don’t even have to have <span id="ITerm54">Docker</span> installed to create and publish Docker Images. Google publishes Jib as both a Maven and a Gradle plugin—you use Maven here.</p>

        </section>

        <section class="Section2 RenderAsSection2" id="Sec25">

          <h3 class="Heading">Understanding the Source Code</h3>

          <div class="Para" id="Par109">The <span id="ITerm55">source code</span> for this book is available on GitHub via the book’s product page, located at <span class="ExternalRef"><a href="http://www.apress.com/9798868805547"><span class="RefSource"><span class="EmphasisFontCategoryNonProportional ">www.apress.com/9798868805547</span></span></a></span>. The code for this example is organized inside the <span class="EmphasisFontCategoryNonProportional ">ch07\ch07-02</span> folder. Much of the source code in this example is similar to that in <span class="EmphasisFontCategoryNonProportional ">ch01\ch01-01</span>. This section does not discuss the code of the microservice since it’s described in Chapter <span class="ExternalRef"><a href="Capítulo-03.html"><span class="RefSource">1</span></a></span>, but it does look into the deployment aspects. Jib will catch any changes you make to the source code of your application each time you build. This saves you separate Docker build/push commands and simplifies adding this to a CI pipeline, but I do not expand on those aspects. You also need to set yourself up locally to authenticate with the Docker repository you want to deploy to. This is done in the Maven <span class="EmphasisFontCategoryNonProportional ">settings.xml</span> <span id="ITerm56">file</span>, as shown in Listing <span class="InternalRef"><a href="#PC23">7-22</a></span>.<div class="ProgramCode" id="PC23"><div class="LineGroup"><div class="FixedLine">(base) binildass-MacBook-Pro:~ binil$ vi /Users/binil/.m2/settings.xml</div><div class="FixedLine">...</div><div class="FixedLine">&lt;settings&gt;</div><div class="FixedLine">    &lt;/servers&gt;</div><div class="FixedLine">        &lt;server&gt;</div><div class="FixedLine">            &lt;id&gt;registry.hub.docker.com&lt;/id&gt;</div><div class="FixedLine">            &lt;username&gt;binildas&lt;/username&gt;</div><div class="FixedLine">            &lt;password&gt;********&lt;/password&gt;</div><div class="FixedLine">        &lt;/server&gt;</div><div class="FixedLine">    &lt;/servers&gt;</div><div class="FixedLine">&lt;/settings&gt;</div><div class="FixedLine">...</div><div class="FixedLine">(base) binildass-MacBook-Pro:~ binil$</div></div><div class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Listing 7-22</span><p class="SimplePara">Maven Settings File</p></div></div></div></div>

          <div class="Para" id="Par110">As you might have guessed, I created an account in the Docker Hub public repository, whose credentials I configured in Listing <span class="InternalRef"><a href="#PC23">7-22</a></span>. Further, the Maven plugin configuration is shown in Listing <span class="InternalRef"><a href="#PC24">7-23</a></span>.<div class="ProgramCode" id="PC24"><div class="LineGroup"><div class="FixedLine">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="FixedLine">&lt;project&gt;</div><div class="FixedLine">    &lt;build&gt;</div><div class="FixedLine">        &lt;pluginManagement&gt;</div><div class="FixedLine">            &lt;plugins&gt;</div><div class="FixedLine">                &lt;plugin&gt;</div><div class="FixedLine">                    &lt;groupId&gt;com.google.cloud.tools&lt;/groupId&gt;</div><div class="FixedLine">                    &lt;artifactId&gt;jib-maven-plugin&lt;/artifactId&gt;</div><div class="FixedLine">                    &lt;version&gt;3.4.1&lt;/version&gt;</div><div class="FixedLine">                &lt;/plugin&gt;</div><div class="FixedLine">            &lt;/plugins&gt;</div><div class="FixedLine">        &lt;/pluginManagement&gt;</div><div class="FixedLine">    &lt;/build&gt;</div><div class="FixedLine">&lt;/project&gt;</div></div><div class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Listing 7-23</span><p class="SimplePara">The Maven <span id="ITerm57">Module Configurations</span> (ch07\ch07-02\pom.xml)</p></div></div></div></div>

          <div class="Para" id="Par111">Jib makes a number of reasonable guesses about what you want, like the <span class="EmphasisFontCategoryNonProportional ">FROM</span> and the <span class="EmphasisFontCategoryNonProportional ">ENTRYPOINT</span> (which you look at next section). Spring Boot exposes port 8080 by default, but if you want to make your application run on port 8081 and make it exposable through a container, you can do this by configuring jib and making appropriate changes in Boot. Further, you can use Jib to make it exposable in the image. Also, by default, Jib uses the distro-less Java image. If you want to run the application on a different base image, such as <span class="EmphasisFontCategoryNonProportional ">alpine-java</span>, you can configure it in a similar way. This section does not go into any of these options, but shows the Docker Hub configuration alone, as in Listing <span class="InternalRef"><a href="#PC25">7-24</a></span>.<div class="ProgramCode" id="PC25"><div class="LineGroup"><div class="FixedLine">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="FixedLine">&lt;project&gt;</div><div class="FixedLine">    &lt;build&gt;</div><div class="FixedLine">        &lt;plugins&gt;</div><div class="FixedLine">            &lt;plugin&gt;</div><div class="FixedLine">                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="FixedLine">                &lt;artifactId&gt;</div><div class="FixedLine">                   spring-boot-maven-plugin</div><div class="FixedLine">                &lt;/artifactId&gt;</div><div class="FixedLine">            &lt;/plugin&gt;</div><div class="FixedLine">            &lt;plugin&gt;</div><div class="FixedLine">                &lt;groupId&gt;com.google.cloud.tools&lt;/groupId&gt;</div><div class="FixedLine">                &lt;artifactId&gt;jib-maven-plugin&lt;/artifactId&gt;</div><div class="FixedLine">                &lt;version&gt;3.2.0&lt;/version&gt;</div><div class="FixedLine">                &lt;configuration&gt;</div><div class="FixedLine">                    &lt;to&gt;</div><div class="FixedLine">                        &lt;image&gt;</div><div class="FixedLine">               registry.hub.docker.com/binildas/product-web</div><div class="FixedLine">                        &lt;/image&gt;</div><div class="FixedLine">                    &lt;/to&gt;</div><div class="FixedLine">                &lt;/configuration&gt;</div><div class="FixedLine">            &lt;/plugin&gt;</div><div class="FixedLine">        &lt;/plugins&gt;</div><div class="FixedLine">    &lt;/build&gt;</div><div class="FixedLine">&lt;/project&gt;</div></div><div class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Listing 7-24</span><p class="SimplePara">The Maven <span id="ITerm58">Build Configurations</span> (ch07\ch07-02\02-ProductWeb\pom.xml)</p></div></div></div></div>

        </section>

        <section class="Section2 RenderAsSection2" id="Sec26">

          <h3 class="Heading">Build and Push Images to Docker Hub</h3>

          <p class="Para" id="Par112">The <span class="EmphasisFontCategoryNonProportional ">ch07\ch07-02</span> folder contains the Maven scripts required to build, containerize, and push an image to Docker Hub.</p>

          <div class="Para" id="Par113">With the Jib plugin, you can use your local Docker instance to build the image from the configuration using this command:<div class="ProgramCode" id="PC26"><div class="LineGroup"><div class="FixedLine">mvn compile jib:dockerBuild</div></div></div></div>

          <div class="Para" id="Par114">However, you can even <span id="ITerm59">build</span> your image without the locally running Docker:<div class="ProgramCode" id="PC27"><div class="LineGroup"><div class="FixedLine">mvn compile jib:build</div></div></div></div>

          <div class="Para" id="Par115">This is shown in Listing <span class="InternalRef"><a href="#PC28">7-25</a></span>.<div class="ProgramCode" id="PC28"><div class="LineGroup"><div class="FixedLine">(base) binildass-MacBook-Pro:ch07-02 binil$ pwd</div><div class="FixedLine">/Users/binil/binil/code/mac/mybooks/docker-04/ch07/ch07-02</div><div class="FixedLine">(base) binildass-MacBook-Pro:ch07-02 binil$ mvn compile jib:build</div><div class="FixedLine">[INFO] Scanning for projects...</div><div class="FixedLine">...</div><div class="FixedLine">[INFO] Containerizing application to registry.hub.docker.com/binildas/product-web...</div><div class="FixedLine">[WARNING] Base image 'eclipse-temurin:8-jre' does not use a specific image digest - build may not be reproducible</div><div class="FixedLine">[INFO] Using credentials from Maven settings file for registry.hub.docker.com/binildas/product-web</div><div class="FixedLine">[INFO] The base image requires auth. Trying again for eclipse-temurin:8-jre...</div><div class="FixedLine">[WARNING] The system does not have docker-credential-desktop CLI</div><div class="FixedLine">[WARNING]   Caused by: Cannot run program "docker-credential-desktop": error=20, Not a directory</div><div class="FixedLine">...</div><div class="FixedLine">[INFO] Using base image with digest: sha256:ca34c4ad9cb6b4fcbfb1ee24c94539901a6266fa585bef4ecfb57bc53468f6f9</div><div class="FixedLine">[INFO]</div><div class="FixedLine">[INFO] Container entrypoint set to [java, -cp, /app/resources:/app/classes:/app/libs/*, com.acme.ecom.product.EcomProductMicroserviceApplication]</div><div class="FixedLine">[INFO]</div><div class="FixedLine">[INFO] Built and pushed image as registry.hub.docker.com/binildas/product-webNFO]</div><div class="FixedLine">...</div><div class="FixedLine">[INFO] -&lt; com.acme.ecom.product:Ecom-Product-Microservice &gt;-</div><div class="FixedLine">[INFO] Building Ecom 0.0.1-SNAPSHOT                                       [2/2]</div><div class="FixedLine">[INFO] --------------------------------[ pom ]------------</div><div class="FixedLine">[INFO]</div><div class="FixedLine">[INFO] --- jib-maven-plugin:3.2.0:build (default-cli) @ Ecom-Product-Microservice ---</div><div class="FixedLine">[INFO] Skipping containerization because packaging is 'pom'...</div><div class="FixedLine">[INFO] ---------------------------------------------------</div><div class="FixedLine">[INFO] Reactor Summary for Ecom 0.0.1-SNAPSHOT:</div><div class="FixedLine">[INFO]</div><div class="FixedLine">[INFO] Ecom-Product-Web-Microservice ...................... SUCCESS [01:52 min]</div><div class="FixedLine">[INFO] Ecom ............................................... SUCCESS [  0.064 s]</div><div class="FixedLine">[INFO] --------------------------------------------------</div><div class="FixedLine">[INFO] BUILD SUCCESS</div><div class="FixedLine">[INFO] --------------------------------------------------</div><div class="FixedLine">[INFO] Total time:  01:52 min</div><div class="FixedLine">[INFO] Finished at: 2022-05-27T10:30:39+05:30</div><div class="FixedLine">[INFO] --------------------------------------------------</div><div class="FixedLine">(base) binildass-MacBook-Pro:ch07-02 binil$</div></div><div class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Listing 7-25</span><p class="SimplePara">Build and Create an Image of Product Server Microservice and Push the Image</p></div></div></div></div>

          <p class="Para" id="Par116">Executing this Maven build will build the Docker image without using your Docker Daemon and will push the image to Docker Hub.</p>

        </section>

        <section class="Section2 RenderAsSection2" id="Sec27">

          <h3 class="Heading">Docker Hub Registry and Repository</h3>

          <div class="Para" id="Par117">As described previously, the component in Docker’s distribution system is the <span id="ITerm60">registry</span>. Images that you build can be pushed and stored in a remote registry for others to use. The Docker Hub is an example of the publicly available registry. It is free and serves a huge, constantly growing collection of existing images. See Figure <span class="InternalRef"><a href="#Fig18">7-18</a></span>.<figure class="Figure" id="Fig18"><div class="MediaObject" id="MO18"><img alt="" aria-describedby="d64e2499" src="../images/619782_1_En_7_Chapter/Imagem-089.jpg" style="width:35.15em"/><div class="TextObject" id="d64e2499"><p class="Para" id="Par171">A screenshot of a web page with the Docker Hub Registry. The page has a search bar, a list of repositories, and a button to create a new repository.</p></div></div><figcaption class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Figure 7-18</span><p class="SimplePara">Docker Hub Registry</p></div></figcaption></figure></div>

          <div class="Para" id="Par118">Figure <span class="InternalRef"><a href="#Fig18">7-18</a></span> shows the Docker Hub registry login interface and many image repositories in it. The repository is a collection (namespace) of related images, which provides different versions of the same application or service. It’s a collection of different Docker images with the same name and different tags. <span class="EmphasisFontCategoryNonProportional ">product-web</span> is one such repository that I pushed as a result of the <span class="EmphasisFontCategoryNonProportional ">jib build</span> command in Listing <span class="InternalRef"><a href="#PC28">7-25</a></span>. Since the app is named <span class="EmphasisFontCategoryNonProportional ">product-web</span> and my username (or namespace) for the registry is <span class="EmphasisFontCategoryNonProportional ">binildas</span>, this image is placed in the <span class="EmphasisFontCategoryNonProportional ">binildas/product-web</span> repository. See Figure <span class="InternalRef"><a href="#Fig19">7-19</a></span>.<figure class="Figure" id="Fig19"><div class="MediaObject" id="MO19"><img alt="" aria-describedby="d64e2538" src="../images/619782_1_En_7_Chapter/Imagem-090.jpg" style="width:35.15em"/><div class="TextObject" id="d64e2538"><p class="Para" id="Par172">A screenshot of a web page of a Docker repository named binildas slash product hyphen web. The repository does not have a description. The last push was 4 months ago with a public view button. It lists the docker commands and tags and scans details.</p></div></div><figcaption class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Figure 7-19</span><p class="SimplePara">Docker repository</p></div></figcaption></figure></div>

          <div class="Para" id="Par119">You can select a specific tag of a repository and delete it. See Figure <span class="InternalRef"><a href="#Fig20">7-20</a></span>.<figure class="Figure" id="Fig20"><div class="MediaObject" id="MO20"><img alt="" aria-describedby="d64e2555" src="../images/619782_1_En_7_Chapter/Imagem-091.jpg" style="width:35.15em"/><div class="TextObject" id="d64e2555"><p class="Para" id="Par173">A screenshot of a web page reading a list of tags in a Docker repository. It lists the tag name, last time the tag was pushed, digest, operating system and architecture, last time the tag was pulled, and compressed size of the tag. A checkbox is next to each tag, and a delete button is at the top.</p></div></div><figcaption class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Figure 7-20</span><p class="SimplePara">Deleting a Docker Repository</p></div></figcaption></figure></div>

        </section>

        <section class="Section2 RenderAsSection2" id="Sec28">

          <h3 class="Heading">Pull Image and Run Container</h3>

          <div class="Para" id="Par120">The next <span id="ITerm61">step</span> is to start the Minikube single-node Kubernetes cluster so that you have a Docker Daemon up. See Listing <span class="InternalRef"><a href="#PC29">7-26</a></span>.<div class="ProgramCode" id="PC29"><div class="LineGroup"><div class="FixedLine">(base) binildass-MacBook-Pro:ch07-02 binil$ minikube start</div><div class="FixedLine">...</div><div class="FixedLine">(base) binildass-MacBook-Pro:ch07-02 binil$</div></div><div class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Listing 7-26</span><p class="SimplePara">Start Minikube</p></div></div></div></div>

          <div class="Para" id="Par121">Next, set the Minikube environment variables in your terminal, as shown in Listing <span class="InternalRef"><a href="#PC30">7-27</a></span>.<div class="ProgramCode" id="PC30"><div class="LineGroup"><div class="FixedLine">(base) binildass-MacBook-Pro:ch07-02 binil$ pwd</div><div class="FixedLine">/Users/binil/binil/code/mac/mybooks/docker-04/ch07/ch07-02</div><div class="FixedLine">(base) binildass-MacBook-Pro:ch07-02 binil$ eval $(minikube docker-env)</div><div class="FixedLine">(base) binildass-MacBook-Pro:ch07-02 binil$</div></div><div class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Listing 7-27</span><p class="SimplePara">Setting <span id="ITerm62">Minikube Environment</span></p></div></div></div></div>

          <div class="Para" id="Par122">Next, we will run the <span id="ITerm63">Product Web microservice</span> in Docker.<div class="ProgramCode" id="PC31"><div class="LineGroup"><div class="FixedLine">(base) binildass-MacBook-Pro:ch07-02 binil$ docker run -it -p 8080:8080 binildas/product-web</div><div class="FixedLine">Unable to find image ' binildas /product-web:latest' locally</div><div class="FixedLine">latest: Pulling from binildas/product-web</div><div class="FixedLine">125a6e411906: Pull complete</div><div class="FixedLine">42222acc001c: Pull complete</div><div class="FixedLine">4da85a7c2f39: Pull complete</div><div class="FixedLine">ebcc7b1a7ad2: Pull complete</div><div class="FixedLine">4edc7728a946: Pull complete</div><div class="FixedLine">9a2bc4698b49: Pull complete</div><div class="FixedLine">68af01cc5861: Pull complete</div><div class="FixedLine">f3636ebea575: Pull complete</div><div class="FixedLine">Digest: sha256:56254d5a6e84cbe625013d245d8fa7dfe157722d0a6dd50d434f8e63dfc339ad</div><div class="FixedLine">Status: Downloaded newer image for binildas/product-web:latest</div></div><div class="LineGroup"><div class="FixedLine">  .   ____          _            __ _ _</div><div class="FixedLine"> /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \</div><div class="FixedLine">( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \</div><div class="FixedLine"> \\/  ___)| |_)| | | | | || (_| |  ) ) ) )</div><div class="FixedLine">  '  |____| .__|_| |_|_| |_\__, | / / / /</div><div class="FixedLine"> =========|_|==============|___/=/_/_/_/</div><div class="FixedLine"> :: Spring Boot ::                (v3.0.6)</div></div><div class="LineGroup"><div class="FixedLine">2022-05-27 05:12:40 INFO  StartupInfoLogger.logStarting:55 - Starting EcomProductMicroserviceA...</div><div class="FixedLine">2022-05-27 05:12:40 DEBUG StartupInfoLogger.logStarting:56 - Running with Spring Boot ...</div><div class="FixedLine">2022-05-27 05:12:40 INFO  SpringApplication.logStartupProfileInfo:662 - No active ...</div><div class="FixedLine">2022-05-27 05:12:41 INFO  InitializationComponent.init:37 - Start</div><div class="FixedLine">2022-05-27 05:12:41 DEBUG InitializationComponent.init:39 - Doing Nothing...</div><div class="FixedLine">2022-05-27 05:12:41 INFO  InitializationComponent.init:41 - End</div><div class="FixedLine">2022-05-27 05:12:42 INFO  StartupInfoLogger.logStarted:61 - Started EcomProductMicroservice...</div><div class="FixedLine">2022-05-27 05:16:03 INFO  ProductRestController.getAllProducts:63 - Start</div><div class="FixedLine">2022-05-27 05:16:03 DEBUG ProductRestController.lambda$getAllProducts$0:73 - Product [productId=1, ...</div><div class="FixedLine">2022-05-27 05:16:03 DEBUG ProductRestController.lambda$getAllProducts$0:73 - Product [productId=2, ...</div></div><div class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Listing 7-28</span><p class="SimplePara">Running Product Web Microservice using Docker</p></div></div></div></div>

          <div class="Para" id="Par123">In the step in Listing <span class="InternalRef"><a href="#PC31">7-28</a></span>, I built using Jib so I directly pushed the Product Web microservice image to Docker Hub. No traces of that is in the <span id="ITerm64">local registry</span>. Why, when I attempted to run the Product Web microservice in Docker in Listing <span class="InternalRef"><a href="#PC31">7-28</a></span>, did it first pull the image to the local registry and then start the container? You can now inspect the Docker Registry, where you will find that the image has been pulled from Docker Hub and is made available in the local registry. See Listing <span class="InternalRef"><a href="#PC32">7-29</a></span>.<div class="ProgramCode" id="PC32"><div class="LineGroup"><div class="FixedLine">(base) binildass-MacBook-Pro:ch07-02 binil$ docker images</div><div class="FixedLine">REPOSITORY            TAG     IMAGE ID       CREATED        SIZE</div><div class="FixedLine">...</div><div class="FixedLine">binildas/product-web  latest  b547edfdc0be   52 years ago   247MB</div><div class="FixedLine">(base) binildass-MacBook-Pro:ch07-02 binil$</div></div><div class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Listing 7-29</span><p class="SimplePara">Inspecting Local Docker Registry</p></div></div></div></div>

          <div class="Para" id="Par124">Ignore the label that the image has been created “52 years ago,” I am not sure why it’s displayed so. Once the container is running, you can list the running containers, as shown in Listing <span class="InternalRef"><a href="#PC33">7-30</a></span>.<div class="ProgramCode" id="PC33"><div class="LineGroup"><div class="FixedLine">(base) binildass-MacBook-Pro:ch07-02 binil$ docker ps</div><div class="FixedLine">CONTAINER ID   IMAGE                  COMMAND                   CREATED        STATUS        PORTS                    NAMES</div><div class="FixedLine">e95b2b5eb64e   binildas/product-web   "java -cp /app/resou..."  6 minutes ago  Up 6 minutes  0.0.0.0:8080-&gt;8080/tcp   loving_williams</div><div class="FixedLine">...</div><div class="FixedLine">(base) binildass-MacBook-Pro:ch07-02 binil$</div></div><div class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Listing 7-30</span><p class="SimplePara">List the Running Containers</p></div></div></div></div>

          <div class="Para" id="Par125">To access the Product Web microservice, as mentioned in Appendix E, you have to get the minikube IP first, which is done in Listing <span class="InternalRef"><a href="#PC34">7-31</a></span>.<div class="ProgramCode" id="PC34"><div class="LineGroup"><div class="FixedLine">(base) binildass-MacBook-Pro:ch07-02 binil$ minikube ip</div><div class="FixedLine">192.168.64.5</div><div class="FixedLine">(base) binildass-MacBook-Pro:ch07-02 binil$</div></div><div class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Listing 7-31</span><p class="SimplePara">Finding Minikube IP</p></div></div></div></div>

          <div class="Para" id="Par126">You can now access the Product Web microservice using your browser with the URL formed with the Minikube IP. See Figure <span class="InternalRef"><a href="#Fig21">7-21</a></span>.<figure class="Figure" id="Fig21"><div class="MediaObject" id="MO21"><img alt="" aria-describedby="d64e2802" src="../images/619782_1_En_7_Chapter/Imagem-092.jpg" style="width:35.15em"/><div class="TextObject" id="d64e2802"><p class="Para" id="Par174">A screenshot of a web page with a table named manage products with a button to add new products. The table has columns for I D, name, code, title, price, and actions. There are two rows in the table, each with a pencil and trash can icon in the actions column.</p></div></div><figcaption class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Figure 7-21</span><p class="SimplePara"><span id="ITerm65">Testing</span> Product Web microservice container</p></div></figcaption></figure></div>

          <p class="Para" id="Par127">Refer to the section titled “Test the Microservice using UI” in Chapter <span class="ExternalRef"><a href="Capítulo-03.html"><span class="RefSource">1</span></a></span> to test the Product Web microservice container.</p>

          <div class="Para" id="Par128">You can now stop the Product Web microservice container, as shown in Listing <span class="InternalRef"><a href="#PC35">7-32</a></span>.<div class="ProgramCode" id="PC35"><div class="LineGroup"><div class="FixedLine">(base) binildass-MacBook-Pro:ch07-02 binil$ docker stop e95b</div><div class="FixedLine">e95b</div><div class="FixedLine">(base) binildass-MacBook-Pro:ch07-02 binil$</div></div><div class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Listing 7-32</span><p class="SimplePara">Stopping Product Web Microservice Container</p></div></div></div></div>

          <p class="Para" id="Par129">Note that <span class="EmphasisFontCategoryNonProportional ">e95b</span> are the first four characters of the ID of the Product Web Microservice container shown in Listing <span class="InternalRef"><a href="#PC33">7-30</a></span>.</p>

          <div class="Para" id="Par130">You can now remove the Product Web microservice container, as shown in Listing <span class="InternalRef"><a href="#PC36">7-33</a></span>.<div class="ProgramCode" id="PC36"><div class="LineGroup"><div class="FixedLine">(base) binildass-MacBook-Pro:ch07-02 binil$ docker rm e95b</div><div class="FixedLine">e95b</div><div class="FixedLine">(base) binildass-MacBook-Pro:ch07-02 binil$</div></div><div class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Listing 7-33</span><p class="SimplePara">Removing Product Web Microservice Container</p></div></div></div></div>

          <div class="Para" id="Par131">You can also remove the Product Web Microservice image from the local Docker Registry, as shown in Listing 7-34.<div class="ProgramCode" id="PC37"><div class="LineGroup"><div class="FixedLine">(base) binildass-MacBook-Pro:ch07-02 binil$ docker rmi b547</div><div class="FixedLine">Untagged: binildas/product-web:latest</div><div class="FixedLine">Untagged: binildas/product-web@sha256:56254d5a6e84cbe625013d245d8fa7dfe157722d0a6dd50d434f8e63dfc339ad</div><div class="FixedLine">Deleted: sha256:b547edfdc0be94d5a44b168ff13f515aa916d63534a2d6075e000ab829a363e8</div><div class="FixedLine">...</div><div class="FixedLine">(base) binildass-MacBook-Pro:ch07-02 binil$</div></div><div class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Listing 7-34</span><p class="SimplePara">Removing Product Web Microservice Image</p></div></div></div></div>

          <p class="Para" id="Par132">Again note that <span class="EmphasisFontCategoryNonProportional ">b547</span> are the first four characters of the ID of the Product Web Microservice image in Listing <span class="InternalRef"><a href="#PC32">7-29</a></span>.</p>

        </section>

      </section>

      <section class="Section1 RenderAsSection1" id="Sec29">

        <h2 class="Heading">Build a Microservice Using a Dockerfile</h2>

        <p class="Para" id="Par133">This section explains how to deploy a microservice using a <span id="ITerm66">Dockerfile</span>. It uses the same microservice deployed in the section titled “Your First Java Microservice” in Chapter <span class="ExternalRef"><a href="Capítulo-03.html"><span class="RefSource">1</span></a></span>.</p>

        <section class="Section2 RenderAsSection2" id="Sec30">

          <h3 class="Heading">Dockerfiles</h3>

          <p class="Para" id="Par134">A <em class="EmphasisTypeItalic ">Dockerfile</em> is a recipe using a plain text file to build a Docker Image. Each Dockerfile specifies a base image that the Docker engine will use to build upon. The Dockerfile then contains a series of instructions on how to build the image. You instruct Docker to create a Docker image based on the <span id="ITerm67">Dockerfile</span>. The <span class="EmphasisFontCategoryNonProportional ">docker build</span> command runs within a build context. The build’s context has the files at a specified location, which can be a <span class="EmphasisFontCategoryNonProportional ">PATH</span> or an <span class="EmphasisFontCategoryNonProportional ">URL</span>. The <span class="EmphasisFontCategoryNonProportional ">PATH</span> is a directory in your local filesystem and the <span class="EmphasisFontCategoryNonProportional ">URL</span> is a Git repository location. The context is processed recursively. <span class="EmphasisFontCategoryNonProportional ">PATH</span> also includes any subdirectories. The URL will include the repository and its submodules.</p>

        </section>

        <section class="Section2 RenderAsSection2" id="Sec31">

          <h3 class="Heading">Understanding the Source Code</h3>

          <div class="Para" id="Par135">The <span id="ITerm68">source code</span> for this book is available on GitHub via the book’s product page, located at <span class="ExternalRef"><a href="http://www.apress.com/9798868805547"><span class="RefSource"><span class="EmphasisFontCategoryNonProportional ">www.apress.com/9798868805547</span></span></a></span>. The code for this example is organized inside the <span class="EmphasisFontCategoryNonProportional ">ch07\ch07-03</span> folder. Much of the source code in this example is similar to the code in <span class="EmphasisFontCategoryNonProportional ">ch01\ch01-01</span>. Hence, this section does not review the microservice code. It looks at several deployment aspects, especially those using the Dockerfile. See Listing <span class="InternalRef"><a href="#PC38">7-35</a></span>.<div class="ProgramCode" id="PC38"><div class="LineGroup"><div class="FixedLine">FROM openjdk:8-jdk-alpine</div><div class="FixedLine">VOLUME /tmp</div><div class="FixedLine">ARG JAR_FILE</div><div class="FixedLine">COPY ${JAR_FILE} ecom.jar</div><div class="FixedLine">ENTRYPOINT ["java","-jar","/ecom.jar"]</div></div><div class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Listing 7-35</span><p class="SimplePara">The Dockerfile (ch07\ch07-03\Dockerfile)</p></div></div></div></div>

          <div class="Para" id="Par136">This Dockerfile contains the following information:<div class="UnorderedList"><ul class="UnorderedListMarkBullet"><li><p class="Para" id="Par137"><span class="EmphasisFontCategoryNonProportional ">FROM</span>: As the base for this image, you’ll take the Java-enabled Alpine Linux by <span class="EmphasisFontCategoryNonProportional ">openjdk</span>, an official repository containing an open-source implementation of the Java platform, Standard Edition.</p></li><li><p class="Para" id="Par138"><span class="EmphasisFontCategoryNonProportional ">VOLUME</span>: This points to <span class="EmphasisFontCategoryNonProportional ">/tmp</span>, because that is where the Spring Boot application creates working directories by default. The effect is to create a temporary file on your host under <span class="EmphasisFontCategoryNonProportional ">/var/lib/docker</span> and link it to the container under <span class="EmphasisFontCategoryNonProportional ">/tmp</span>. This is essential when running the container as a non-root user.</p></li><li><p class="Para" id="Par139"><span class="EmphasisFontCategoryNonProportional ">ARG</span>: This is also known as a build-time variable. They are only available from the moment they are “announced” in the Dockerfile with an <span class="EmphasisFontCategoryNonProportional ">ARG</span> instruction until the moment the image is built. Running containers can’t access values of <span class="EmphasisFontCategoryNonProportional ">ARG</span> variables.</p></li><li><p class="Para" id="Par140"><span class="EmphasisFontCategoryNonProportional ">COPY</span>: Docker copies the Jar file into the image.</p></li><li><p class="Para" id="Par141"><span class="EmphasisFontCategoryNonProportional ">ENTRYPOINT</span>: This will be the executable to start when the container is booting. Defined as <span class="EmphasisFontCategoryNonProportional ">JSON-Array</span> since you’ll use an <span class="EmphasisFontCategoryNonProportional ">ENTRYPOINT</span> in combination with a <span class="EmphasisFontCategoryNonProportional ">CMD</span> for some application arguments.</p></li></ul></div></div>

          <div class="Para" id="Par142">The single script in Listing <span class="InternalRef"><a href="#PC39">7-36</a></span> is used to automate this build process.<div class="ProgramCode" id="PC39"><div class="LineGroup"><div class="FixedLine">mvn -Dmaven.test.skip=true clean package</div><div class="FixedLine">docker build  --build-arg JAR_FILE=02-ProductWeb/target/*.jar -t binildas/product-web .</div><div class="FixedLine">docker push binildas/product-web</div><div class="FixedLine">sleep 10</div><div class="FixedLine">docker rmi binildas/product-web</div><div class="FixedLine">sleep 10</div><div class="FixedLine">docker run -p 8080:8080  --name product-web binildas/product-web</div></div><div class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Listing 7-36</span><p class="SimplePara">The Docker Build Script (ch07\ch07-03\makeandrun.sh)</p></div></div></div></div>

        </section>

        <section class="Section2 RenderAsSection2" id="Sec32">

          <h3 class="Heading">Build and Run the Microservice Using a Dockerfile</h3>

          <div class="Para" id="Par143">The next step is to start the <span id="ITerm69">Minikube</span> single-node Kubernetes cluster so that you have a Docker Daemon up. See Listing <span class="InternalRef"><a href="#PC40">7-37</a></span>.<div class="ProgramCode" id="PC40"><div class="LineGroup"><div class="FixedLine">(base) binildass-MacBook-Pro:ch07-03 binil$ minikube start</div><div class="FixedLine">...</div><div class="FixedLine">(base) binildass-MacBook-Pro:ch07-03 binil$</div></div><div class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Listing 7-37</span><p class="SimplePara">Starting Minikube</p></div></div></div></div>

          <div class="Para" id="Par144">Next, set the <span id="ITerm70">Minikube environment variables</span> in your terminal, as shown in Listing <span class="InternalRef"><a href="#PC41">7-38</a></span>.<div class="ProgramCode" id="PC41"><div class="LineGroup"><div class="FixedLine">(base) binildass-MacBook-Pro:ch07-03 binil$ pwd</div><div class="FixedLine">/Users/binil/binil/code/mac/mybooks/docker-04/ch07/ch07-03</div><div class="FixedLine">(base) binildass-MacBook-Pro:ch07-03 binil$ eval $(minikube docker-env)</div><div class="FixedLine">(base) binildass-MacBook-Pro:ch07-03 binil$</div></div><div class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Listing 7-38</span><p class="SimplePara">Setting Minikube Environment in Terminal</p></div></div></div></div>

          <div class="Para" id="Par145">Next, you can try to run the Product Web microservice in Docker. As you see in Listing <span class="InternalRef"><a href="#PC39">7-36</a></span>, you use the <span class="EmphasisFontCategoryNonProportional ">docker push</span> command. To facilitate this, you need to log in to Docker Hub in your current terminal. See Listing <span class="InternalRef"><a href="#PC42">7-39</a></span>.<div class="ProgramCode" id="PC42"><div class="LineGroup"><div class="FixedLine">(base) binildass-MacBook-Pro:ch07-03 binil$ docker login</div><div class="FixedLine">Login with your Docker ID to push and pull images from Docker Hub. If you don't have a Docker ID, head over to https://hub.docker.com to create one.</div><div class="FixedLine">Username: binildas</div><div class="FixedLine">Password:</div><div class="FixedLine">Error saving credentials: error storing credentials - err: exec: "docker-credential-desktop": executable file not found in $PATH, out: ``</div><div class="FixedLine">(base) binildass-MacBook-Pro:ch07-03 binil$</div></div><div class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Listing 7-39</span><p class="SimplePara">Log in to Docker Terminal</p></div></div></div></div>

          <div class="Para" id="Par146">The error in Listing <span class="InternalRef"><a href="#PC42">7-39</a></span> happens because you are not dealing with the host filesystem, but with the filesystem in your Minikube VM. Hence, if you try to push the Docker Image to Docker Hub, you might not be successful. See Listing <span class="InternalRef"><a href="#PC43">7-40</a></span>.<div class="ProgramCode" id="PC43"><div class="LineGroup"><div class="FixedLine">(base) binildass-MacBook-Pro:ch07-03 binil$ sh makeandrun.sh</div></div><div class="LineGroup"><div class="FixedLine">(base) binildass-MacBook-Pro:ch07-03 binil$ pwd</div><div class="FixedLine">/Users/binil/binil/code/mac/mybooks/docker-04/ch07/ch07-03</div><div class="FixedLine">(base) binildass-MacBook-Pro:ch07-03 binil$ docker push binildas/product-web</div><div class="FixedLine">Using default tag: latest</div><div class="FixedLine">The push refers to repository [docker.io/binildas/product-web]</div><div class="FixedLine">2c54cf7f9c27: Preparing</div><div class="FixedLine">ceaf9e1ebef5: Preparing</div><div class="FixedLine">9b9b7f3d56a0: Preparing</div><div class="FixedLine">f1b5933fe4b5: Preparing</div><div class="FixedLine">denied: requested access to the resource is denied</div><div class="FixedLine">(base) binildass-MacBook-Pro:ch07-03 binil$</div></div><div class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Listing 7-40</span><p class="SimplePara">Log in to Docker Terminal</p></div></div></div></div>

          <div class="Para" id="Par147">As mentioned, there is an error in Listing <span class="InternalRef"><a href="#PC43">7-40</a></span>, so set aside the <span class="EmphasisFontCategoryNonProportional ">makeandrun.sh</span> automation script and try this manually, step by step. See Listings <span class="InternalRef"><a href="#PC44">7-41</a></span> and <span class="InternalRef"><a href="#PC45">7-42</a></span>.<div class="ProgramCode" id="PC44"><div class="LineGroup"><div class="FixedLine">(base) binildass-MacBook-Pro:ch07-03 binil$ pwd</div><div class="FixedLine">/Users/binil/binil/code/mac/mybooks/docker-04/ch07/ch07-03</div><div class="FixedLine">(base) binildass-MacBook-Pro:ch07-03 binil$ mvn -Dmaven.test.skip=true clean package</div><div class="FixedLine">[INFO] Scanning for projects...</div><div class="FixedLine">...</div><div class="FixedLine">[INFO] Ecom-Product-Web-Microservice ... SUCCESS [  1.622 s]</div><div class="FixedLine">[INFO] Ecom ............................ SUCCESS [  0.017 s]</div><div class="FixedLine">[INFO] -------------------------------------------------</div><div class="FixedLine">[INFO] BUILD SUCCESS</div><div class="FixedLine">[INFO] --------------------------------------------------</div><div class="FixedLine">[INFO] Total time:  1.796 s</div><div class="FixedLine">[INFO] Finished at: 2022-05-27T11:50:50+05:30</div><div class="FixedLine">[INFO] --------------------------------------------------</div><div class="FixedLine">(base) binildass-MacBook-Pro:ch07-03 binil$</div></div><div class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Listing 7-41</span><p class="SimplePara">Build and Package Product Web Microservice</p></div></div></div><div class="ProgramCode" id="PC45"><div class="LineGroup"><div class="FixedLine">(base) binildass-MacBook-Pro:ch07-03 binil$ docker build  --build-arg JAR_FILE=02-ProductWeb/target/*.jar -t binildas/product-web .</div><div class="FixedLine">Sending build context to Docker daemon  21.68MB</div><div class="FixedLine">Step 1/5 : FROM openjdk:8-jdk-alpine</div><div class="FixedLine"> ---&gt; a3562aa0b991</div><div class="FixedLine">Step 2/5 : VOLUME /tmp</div><div class="FixedLine"> ---&gt; Running in b33ed0a15fb0</div><div class="FixedLine">Removing intermediate container b33ed0a15fb0</div><div class="FixedLine"> ---&gt; 388ef9de0cd0</div><div class="FixedLine">Step 3/5 : ARG JAR_FILE</div><div class="FixedLine"> ---&gt; Running in cdab850cc040</div><div class="FixedLine">Removing intermediate container cdab850cc040</div><div class="FixedLine"> ---&gt; 9c06159a60bf</div><div class="FixedLine">Step 4/5 : COPY ${JAR_FILE} ecom.jar</div><div class="FixedLine"> ---&gt; 9ed33fae3b42</div><div class="FixedLine">Step 5/5 : ENTRYPOINT ["java","-jar","/ecom.jar"]</div><div class="FixedLine"> ---&gt; Running in 0949e3c49a48</div><div class="FixedLine">Removing intermediate container 0949e3c49a48</div><div class="FixedLine"> ---&gt; 079251d7b3b0</div><div class="FixedLine">Successfully built 079251d7b3b0</div><div class="FixedLine">Successfully tagged binildas/product-web:latest</div><div class="FixedLine">(base) binildass-MacBook-Pro:ch07-03 binil$</div></div><div class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Listing 7-42</span><p class="SimplePara">Build an Image of Product Web Microservice</p></div></div></div></div>

          <div class="Para" id="Par148">Since you utilized the Docker Daemon in Minikube (refer to Appendix E), the image is crated in the local registry of the Docker Daemon. You should also push this to Docker Hub. Since you are not dealing with the host filesystem but with the one in your Minikube VM, you need to log in to the VM and execute the push. See Listing <span class="InternalRef"><a href="#PC46">7-43</a></span>.<div class="ProgramCode" id="PC46"><div class="LineGroup"><div class="FixedLine">(base) binildass-MacBook-Pro:ch07-03 binil$ pwd</div><div class="FixedLine">/Users/binil/binil/code/mac/mybooks/docker-04/ch07/ch07-03</div><div class="FixedLine">(base) binildass-MacBook-Pro:ch07-03 binil$ minikube ssh</div><div class="FixedLine">                         _             _</div><div class="FixedLine">            _         _ ( )           ( )</div><div class="FixedLine">  ___ ___  (_)  ___  (_)| |/')  _   _ | |_      __</div><div class="FixedLine">/' _ ` _ `\| |/' _ `\| || , &lt;  ( ) ( )| '_`\  /'__`\</div><div class="FixedLine">| ( ) ( ) || || ( ) || || |\`\ | (_) || |_) )(  ___/</div><div class="FixedLine">(_) (_) (_)(_)(_) (_)(_)(_) (_)`\___/'(_,__/'`\____)</div></div><div class="LineGroup"><div class="FixedLine">$ docker login</div><div class="FixedLine">Login with your Docker ID to push and pull images from Docker Hub. If you don't have a Docker ID, head over to https://hub.docker.com to create one.</div><div class="FixedLine">Username: binildas</div><div class="FixedLine">Password:</div><div class="FixedLine">WARNING! Your password will be stored unencrypted in /home/docker/.docker/config.json.</div><div class="FixedLine">Configure a credential helper to remove this warning. See</div><div class="FixedLine">https://docs.docker.com/engine/reference/commandline/login/#credentials-store</div></div><div class="LineGroup"><div class="FixedLine">Login Succeeded</div><div class="FixedLine">$ docker push binildas/product-web</div><div class="FixedLine">Using default tag: latest</div><div class="FixedLine">The push refers to repository [docker.io/binildas/product-web]</div><div class="FixedLine">2c54cf7f9c27: Pushed</div><div class="FixedLine">ceaf9e1ebef5: Layer already exists</div><div class="FixedLine">9b9b7f3d56a0: Layer already exists</div><div class="FixedLine">f1b5933fe4b5: Layer already exists</div><div class="FixedLine">latest: digest: sha256:420cc888c575f695b5f2b84092b6bfa73d153bc0937cb846a28366ff14fa1f04 size: 1159</div><div class="FixedLine">$ exit</div><div class="FixedLine">logout</div><div class="FixedLine">(base) binildass-MacBook-Pro:ch07-03 binil$</div></div><div class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Listing 7-43</span><p class="SimplePara"><span id="ITerm71">Push Image</span> of Product Web Microservice</p></div></div></div></div>

          <div class="Para" id="Par149"><span id="ITerm72"></span>To make sure you actually pushed the image, you can remove the local image and attempt to run the Product Web microservice container, as shown in Listing <span class="InternalRef"><a href="#PC47">7-44</a></span>.<div class="ProgramCode" id="PC47"><div class="LineGroup"><div class="FixedLine">(base) binildass-MacBook-Pro:ch07-03 binil$ pwd</div><div class="FixedLine">/Users/binil/binil/code/mac/mybooks/docker-04/ch07/ch07-03</div><div class="FixedLine">(base) binildass-MacBook-Pro:ch07-03 binil$ docker rmi binildas/product-web</div><div class="FixedLine">Untagged: binildas/product-web:latest</div><div class="FixedLine">Untagged: binildas/product-web@sha256:420cc888c575f695b5f2b84092b6bfa73d153bc0937cb846a28366ff14fa1f04</div><div class="FixedLine">Deleted: sha256:079251d7b3b01df698620fc9648125c62b220de7f031e3610d06970d994ca2ed</div><div class="FixedLine">...</div><div class="FixedLine">(base) binildass-MacBook-Pro:ch07-03 binil$</div></div><div class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Listing 7-44</span><p class="SimplePara"><span id="ITerm73">Remove Image</span> of Product Web Microservice from Local</p></div></div></div></div>

          <div class="Para" id="Par150">Next, run the Microservice container, as shown in Listing <span class="InternalRef"><a href="#PC48">7-45</a></span>.<div class="ProgramCode" id="PC48"><div class="LineGroup"><div class="FixedLine">(base) binildass-MacBook-Pro:ch07-03 binil$ docker run -p 8080:8080  --name product-web binildas/product-web</div><div class="FixedLine">Unable to find image 'binildas/product-web:latest' locally</div><div class="FixedLine">latest: Pulling from binildas/product-web</div><div class="FixedLine">e7c96db7181b: Already exists</div><div class="FixedLine">f910a506b6cb: Already exists</div><div class="FixedLine">c2274a1a0e27: Already exists</div><div class="FixedLine">fa880b6dd374: Pull complete</div><div class="FixedLine">Digest: sha256:420cc888c575f695b5f2b84092b6bfa73d153bc0937cb846a28366ff14fa1f04</div><div class="FixedLine">Status: Downloaded newer image for binildas/product-web:latest</div></div><div class="LineGroup"><div class="FixedLine">  .   ____          _            __ _ _</div><div class="FixedLine"> /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \</div><div class="FixedLine">( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \</div><div class="FixedLine"> \\/  ___)| |_)| | | | | || (_| |  ) ) ) )</div><div class="FixedLine">  '  |____| .__|_| |_|_| |_\__, | / / / /</div><div class="FixedLine"> =========|_|==============|___/=/_/_/_/</div><div class="FixedLine"> :: Spring Boot ::                (v3.0.6)</div></div><div class="LineGroup"><div class="FixedLine">2022-05-27 06:40:30 INFO  StartupInfoLogger.logStarting:55 - Starting EcomProductMicroservice...</div><div class="FixedLine">2022-05-27 06:40:30 DEBUG StartupInfoLogger.logStarting:56 - Running with Spring Boot ...</div><div class="FixedLine">2022-05-27 06:40:30 INFO  SpringApplication.logStartupProfileInfo:662 - No active ...</div><div class="FixedLine">2022-05-27 06:40:31 INFO  InitializationComponent.init:37 - Start</div><div class="FixedLine">2022-05-27 06:40:31 DEBUG InitializationComponent.init:39 - Doing Nothing...</div><div class="FixedLine">2022-05-27 06:40:31 INFO  InitializationComponent.init:41 - End</div><div class="FixedLine">2022-05-27 06:40:32 INFO  StartupInfoLogger.logStarted:61 - Started EcomProductMicroser...</div><div class="FixedLine">2022-05-27 06:42:49 DEBUG ProductRestController.lambda$getAllProducts$0:73 - Product [productId=1...</div><div class="FixedLine">2022-05-27 06:42:49 DEBUG ProductRestController.lambda$getAllProducts$0:73 - Product [productId=2...</div></div><div class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Listing 7-45</span><p class="SimplePara">Run Product Web Microservice Container</p></div></div></div></div>

          <p class="Para" id="Par151">In Listing <span class="InternalRef"><a href="#PC48">7-45</a></span>, you are pulling the image from the Docker Hub Registry. You can now access the Product Web microservice using a browser with the URL formed with the Minikube IP:</p>

          <p class="Para ParaOneEmphasisChild" id="Par152"><span class="EmphasisFontCategoryNonProportional ">http://192.168.64.5:8080/product.html</span></p>

        </section>

      </section>

      <section class="Section1 RenderAsSection1" id="Sec33">

        <h2 class="Heading">Summary</h2>

        <p class="Para" id="Par153">Containers are great at packaging, shipping, and getting the code executed from a target environment without having to set many application-specific settings on the target machine. You can treat a container as a black box. To demonstrate that, this chapter included examples of building, packaging, and executing Java code without a local Java SDK, but with just a Maven in a container! You also learned about various ways to handle containers in order to interact with simple microservices. You are now in a better position to appreciate what a container is. The next chapter covers more serious microservices, also using containers.</p>

      </section>

    </div>

  </div>

</body>

</html>