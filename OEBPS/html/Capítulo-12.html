<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" lang="en">

<head>
  <title>Microservices with Kubernetes</title>
  <link href="../css/springer_epub.css" rel="styleSheet" type="text/css"/>
</head>

<body>

  <div epub:type="chapter" role="doc-chapter">

    <div class="ChapterContextInformation">

      <div class="ContextInformation" id="b979-8-8688-0555-4_10"><div class="ChapterCopyright">© The Author(s), under exclusive license to APress Media, LLC, part of Springer Nature 2024</div><span class="ContextInformationAuthorEditorNames">B. A. Christudas</span><span class="ContextInformationBookTitles"><span class="BookTitle">Java Microservices and Containers in the Cloud</span></span><span class="ChapterDOI"><a href="https://doi.org/10.1007/979-8-8688-0555-4_10">https://doi.org/10.1007/979-8-8688-0555-4_10</a></span></div>

    </div>

    <!--Begin Abstract-->

    <div class="MainTitleSection">

      <h1 class="ChapterTitle" lang="en">10. Microservices with Kubernetes</h1>

    </div>

    <div class="AuthorGroup">

      <div class="AuthorNames"><span class="Author"><span class="AuthorName">Binildas A. Christudas</span><sup><a href="#Aff2">1</a> <span class="ContactIcon"> </span></sup></span></div>

      <div class="Affiliations">

        <div class="Affiliation" id="Aff2"><span class="AffiliationNumber">(1)</span><div class="AffiliationText">NBCRA 45, Christbin, Thiruvananthapuram, Kerala, India</div></div>

        <div class="ClearBoth"> </div>

      </div>

    </div>

    <!--End Abstract-->

    <div class="Fulltext">

      <p class="Para" id="Par2">Chapter <span class="ExternalRef"><a href="Capítulo-03.html"><span class="RefSource">1</span></a></span> discussed various levels of service granularity. As you keep splitting services into finer services, you are in fact increasing the number of moving parts in your architecture. This kind of <span id="ITerm1">divide-and-conquer approach</span> in splitting to finer services is attempting to decrease the risk of an individual service failure bringing down your entire application. But on the other hand, as you increase the number of moving parts, you also increase the number of links between these moving parts, thus increasing the blast area prone to failures.</p>

      <p class="Para" id="Par3"><span id="ITerm2">Monolithic applications</span> consist of components and modules that are all tightly coupled and must be developed, deployed, operated, and managed as one entity, because they all run as a single process. Running a monolithic application usually requires one or a few powerful servers that can provide enough resources to run the application. When the load on the application increases, you can <em class="EmphasisTypeItalic ">vertically</em> scale (by increasing hardware specs) or <em class="EmphasisTypeItalic ">horizontally</em> scale (by introducing more replicas of the process) the application.</p>

      <p class="Para" id="Par4">When you move from monolithic to <span id="ITerm3">microservices</span>, most of these scaling principles are applicable, but since you have increased the number of moving parts, the overall complexity also increases many fold. In fact, the degree of complexity keeps increasing more than proportional to the new elements. You might have seen this in the chapters on Docker, where I talked about images and containers, which are over and above the classical existing .<span class="EmphasisFontCategoryNonProportional ">jar</span> formatted <span id="ITerm4">artifacts</span>. You need a toolset and an ecosystem to better manage your application binaries in their static form (.<span class="EmphasisFontCategoryNonProportional ">jar</span> and images) and in their dynamic form (containers). This topic is covered in this chapter.</p>

      <div class="Para" id="Par5">The following concepts are covered in this chapter.<div class="UnorderedList"><ul class="UnorderedListMarkBullet"><li><p class="Para" id="Par6">Introduction to the Kubernetes architecture</p></li><li><p class="Para" id="Par7">Selected Kubernetes deployment aspects</p></li><li><p class="Para" id="Par8">Traffic and state management in Kubernetes</p></li><li><p class="Para" id="Par9">Composing microservices and database containers together in Kubernetes</p></li><li><p class="Para" id="Par10">Demonstrating Full CRUD functionality across the containers composed in Kubernetes</p></li></ul></div></div>

      <section class="Section1 RenderAsSection1" id="Sec1">

        <h2 class="Heading">The World of Kubernetes</h2>

        <p class="Para" id="Par11">The act of splitting <span id="ITerm5">monolithic applications</span> into finer, independently deployable components called microservices, packaging them as container images, and instantiating them into containers is the way forward. Each microservice is packaged into an image and runs as an independent process in the container. Each microservice communicates with other microservices through well-defined interfaces (APIs).</p>

        <div class="Para" id="Par12">Figure <span class="InternalRef"><a href="#Fig1">10-1</a></span> shows the different modes of <span id="ITerm6">virtualizations and application deployments</span> from Chapter <span class="ExternalRef"><a href="Capítulo-09.html"><span class="RefSource">7</span></a></span>. In the containerized mode, the business applications are instantiated as containers over a container runtime. Docker is the container runtime used in this book. In a microservices-based architecture, you have many containers. To be specific, you may have one or more containers from the same <span id="ITerm7">Docker image</span> or from different Docker images. When you have many such containers, this is where you need a container management tool or a container orchestration tool like Kubernetes.<figure class="Figure" id="Fig1"><div class="MediaObject" id="MO1"><img alt="" aria-describedby="d64e261" src="../images/619782_1_En_10_Chapter/Imagem-106.jpg" style="width:35.15em"/><div class="TextObject" id="d64e261"><p class="Para" id="Par194">A diagram illustrates the evolution of containerization technologies from traditional monolithic applications to kubernetes-based orchestration. It highlights the increased efficiency, scalability, and portability offered by containerization through hardware like C P U, disk, memory, and network.</p></div></div><figcaption class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Figure 10-1</span><p class="SimplePara">The Kubernetes <span id="ITerm8">ecosystem</span><span id="ITerm9"></span></p></div></figcaption></figure></div>

        <p class="Para" id="Par13">Running containers is like running processes, which require their own housekeeping to be performed. Starting and stopping your containerized applications, rolling out updates, maintaining service levels, scaling containers to meet varying loads, securing access, and so on, are just a few of the many such housekeeping jobs to be performed. This section looks at how Kubernetes helps in this regard.</p>

      </section>

      <section class="Section1 RenderAsSection1" id="Sec2">

        <h2 class="Heading">Kubernetes Architecture</h2>

        <p class="Para" id="Par14">Kubernetes is a container orchestrator. It manages running containers. A Kubernetes <span id="ITerm10">architecture</span> is composed of multiple nodes, which are classified into master nodes and worker nodes. The master nodes host the <span id="ITerm11">Kubernetes Control Plane</span>, whereas the worker nodes host your actual container applications.</p>

        <div class="Para" id="Par15">You can investigate these nodes with the help of Figure <span class="InternalRef"><a href="#Fig2">10-2</a></span>.<figure class="Figure" id="Fig2"><div class="MediaObject" id="MO2"><img alt="" aria-describedby="d64e303" src="../images/619782_1_En_10_Chapter/Imagem-107.jpg" style="width:35.15em"/><div class="TextObject" id="d64e303"><p class="Para" id="Par195">An architecture comprises a control plane with multiple master nodes and worker nodes. It includes A P I server, controller-manager, and scheduler. Worker nodes run kubelet, kube-proxy, and container runtime. A load balancer and H A proxy and keepalived are for service discovery and load balancing.</p></div></div><figcaption class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Figure 10-2</span><p class="SimplePara">The Kubernetes <span id="ITerm12">architecture</span></p></div></figcaption></figure></div>

        <p class="Para" id="Par16">The next section looks at the Kubernetes architecture at a high level.</p>

        <section class="Section2 RenderAsSection2" id="Sec3">

          <h3 class="Heading">The Control Plane</h3>

          <div class="Para" id="Par17">The master node hosts the Kubernetes Control Plane; it also controls and manages the Kubernetes system. The <span id="ITerm13">components</span> of the Kubernetes Control Plane are listed here:<div class="UnorderedList"><ul class="UnorderedListMarkBullet"><li><p class="Para" id="Par18">The Kubernetes API server: The developer and the other components of the Kubernetes Control Plane communicate with the Control Plane using the Kubernetes API Server.</p></li><li><p class="Para" id="Par19">The Scheduler: Schedules the jobs or workloads into the worker nodes of your Kubernetes cluster.</p></li><li><p class="Para" id="Par20">The Control Manager: Performs Kubernetes cluster-level functions, such as replicating instances, keeping track of worker nodes, and so on.</p></li><li><p class="Para" id="Par21">etcd: A reliable, distributed, and persistent data store that stores the cluster configurations.</p></li></ul></div></div>

        </section>

        <section class="Section2 RenderAsSection2" id="Sec4">

          <h3 class="Heading">The Node</h3>

          <div class="Para" id="Par22">The <span id="ITerm14">nodes</span>, or the worker nodes, run your containerized applications. The major components are listed here:<div class="UnorderedList"><ul class="UnorderedListMarkBullet"><li><p class="Para" id="Par23">Container runtime: Runs your containers. Docker, rkt, and so on, are different container runtimes.</p></li><li><p class="Para" id="Par24">The Kubelet: Talks to the API server of the Control Plane and manages containers on the respective nodes.</p></li><li><p class="Para" id="Par25">The kube-proxy: Otherwise known as the Kubernetes Service Proxy, this load balances network traffic between application components.</p></li></ul></div></div>

          <p class="Para" id="Par26">Figure <span class="InternalRef"><a href="#Fig2">10-2</a></span> depicts the Control Plane and the worker nodes. When you set up a Kubernetes cluster on-premises for a production environment, it is recommended that you deploy it in <span id="ITerm15">high availability (HA) mode</span>. High availability means installing Kubernetes master or Control Plane in HA mode, as shown in Figure <span class="InternalRef"><a href="#Fig2">10-2</a></span>.</p>

        </section>

      </section>

      <section class="Section1 RenderAsSection1" id="Sec5">

        <h2 class="Heading">Kubernetes Deployment</h2>

        <p class="Para" id="Par27">You use different kinds of API objects to <span id="ITerm16">deploy</span> workloads in Kubernetes. This section briefly looks into a few of them.</p>

        <section class="Section2 RenderAsSection2" id="Sec6">

          <h3 class="Heading">Containers</h3>

          <p class="Para" id="Par28">In the previous two chapters on Docker, you learned how a container works. When it comes to Kubernetes, you use those same containers as the basic unit of work. Any workload or application that runs in Kubernetes, must run inside a container. This container could be a Docker container, a rkt container, or a <span id="ITerm17">virtual machine (VM)</span> managed by Virtlet.</p>

          <p class="Para" id="Par29">When containers are orchestrated using Kubernetes, Kubernetes needs additional information for container management, such as a restart policy, a liveness probe, and so on. Kubernetes <span id="ITerm18">architecture</span> abstracts for such additional requirements into what is called a <em class="EmphasisTypeItalic ">pod</em>.</p>

        </section>

        <section class="Section2 RenderAsSection2" id="Sec7">

          <h3 class="Heading">Pods</h3>

          <div class="Para" id="Par30"><span id="ITerm19">Pods</span> are the smallest deployable unit in Kubernetes. A pod will contain a container but can run multiple containers (meaning multiple applications) within it too. A pod is a wrapper on top of one or more running containers. Using pods, Kubernetes controls, monitors, and operates the containers.<figure class="Figure" id="Fig3"><div class="MediaObject" id="MO3"><img alt="" aria-describedby="d64e440" src="../images/619782_1_En_10_Chapter/Imagem-108.jpg" style="width:35.15em"/><div class="TextObject" id="d64e440"><p class="Para" id="Par196">A diagram illustrates the kubernetes deployment resource. Deployment consists of a replica set, which manages a set of pods. Each pod contains one or more containers. A volume can be shared among containers within a pod. Deployments provide mechanisms for updates, rollbacks, and self-healing.</p></div></div><figcaption class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Figure 10-3</span><p class="SimplePara">Kubernetes <span id="ITerm20">deployment</span></p></div></figcaption></figure></div>

          <p class="Para" id="Par31">Containers in a pod run on a “logical host,” since they lie in the same node (i.e., they use the same network namespace and the same IPC namespace). They can also use shared volumes, as depicted in Figure <span class="InternalRef"><a href="#Fig3">10-3</a></span>.</p>

          <p class="Para" id="Par32">When an application requires more than one container running on the same host, and when those containers need to efficiently communicate ensuring data locality, they can be in the same pod. This provides process isolation; it’s easier to troubleshoot the container because logs from different processes are not mixed.</p>

        </section>

        <section class="Section2 RenderAsSection2" id="Sec8">

          <h3 class="Heading">ReplicaSets</h3>

          <p class="Para" id="Par33">Kubernetes allows you to imperatively or declaratively define and create a <em class="EmphasisTypeItalic ">ReplicaSet</em>. A <span id="ITerm21">ReplicaSet</span> is a set of replicas (pods) maintained with their revision history. A ReplicaSet’s job is to constantly monitor the list of running pods and make sure the running number of pods of a certain specification always match the desired number. Thus, a ReplicaSet is used to define and manage a collection of identical pods that are running on different cluster nodes. A <span id="ITerm22">ReplicaSet</span> defines which container images are used by the containers running inside a pod and how many instances of the pod will run in the cluster, among other things.</p>

        </section>

        <section class="Section2 RenderAsSection2" id="Sec9">

          <h3 class="Heading">Deployment</h3>

          <div class="Para" id="Par34"><span id="ITerm23">Deployment</span> is a higher-level resource meant for deploying applications and updating them declaratively. When you create a Deployment, one or more ReplicaSet resources are created underneath. When using a Deployment, the actual pods are created and managed by the Deployment’s ReplicaSets, not by the Deployment directly. See Figure <span class="InternalRef"><a href="#Fig4">10-4</a></span>.<figure class="Figure" id="Fig4"><div class="MediaObject" id="MO4"><img alt="" aria-describedby="d64e496" src="../images/619782_1_En_10_Chapter/Imagem-109.jpg" style="width:35.15em"/><div class="TextObject" id="d64e496"><p class="Para" id="Par197">A tree diagram illustrates kubernetes deployment resources. A deployment consists of multiple replica sets, each of which manages a set of pods. Each pod has a container. Pods are scheduled to run on nodes.</p></div></div><figcaption class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Figure 10-4</span><p class="SimplePara">Kubernetes <span id="ITerm24">deployment</span> across nodes</p></div></figcaption></figure></div>

        </section>

      </section>

      <section class="Section1 RenderAsSection1" id="Sec10">

        <h2 class="Heading">Accessing Kubernetes Services</h2>

        <p class="Para" id="Par35">Having looked at the <span id="ITerm25">deployment</span> schema adopted with Kubernetes, this section looks at the access mechanism for accessing the workloads deployed in Kubernetes.</p>

        <section class="Section2 RenderAsSection2" id="Sec11">

          <h3 class="Heading">Accessing Kubernetes Deployments</h3>

          <p class="Para" id="Par36">In Kubernetes, pods are created and destroyed to match the desired state of your cluster, as specified in your deployment descriptor. Pods are temporary resources. When you use a Deployment to run your Kubernetes application, it can create and destroy pods on the fly. When pods are created, each pod gets its own IP address. When you use a <span id="ITerm26">Deployment</span>, the set of pods running in one moment in time can be different than the set of pods running the same application a moment later.</p>

          <p class="Para" id="Par37">Upon creation, pods are assigned an IP address. These IP addresses are visible in the cluster, which allows access from within the cluster. Other pods in the cluster can access that IP address and inter-pod communication can happen. When a pod dies, a new pod will be created that comes into service with a new IP address and anything trying to communicate with the dead pod somehow needs to know about this new address. Kubernetes provides a “service,” which is an abstract way to expose an application running on a set of pods as a network service.</p>

        </section>

        <section class="Section2 RenderAsSection2" id="Sec12">

          <h3 class="Heading">Kubernetes Service</h3>

          <div class="Para" id="Par38">The pods you saw earlier from the Deployment object can be killed or scaled up and down, so you can’t rely on their IP addresses because they are not persistent. Once a pod is defined, it will exhibit the following essential but not so straight <span id="ITerm27">characteristics</span>:<div class="UnorderedList"><ul class="UnorderedListMarkBullet"><li><p class="Para" id="Par39">Pods are ephemeral: Pods are like “tellers in a bank” in the sense that you are not served by the same teller (person) every time. Similarly pods can come and go. During scale up or scale down, pods may come and go, and if a crash occurs, pods might go and may be re-created.</p></li><li><p class="Para" id="Par40">Post create IP: Kubernetes assigns an <span id="ITerm28">IP address</span> to a pod after the pod has been scheduled and started. So clients can’t know the IP address of the pod upfront.</p></li><li><p class="Para" id="Par41">Dynamic IP list: Scaling out means more than one pod of the same type may provide the same service. Each of these (dynamic) pods has its own IP address and it may not be practical for clients to bind to a dynamic list of IPs easily. Rather, all these pods should be accessible through a single address.</p></li></ul></div></div>

          <div class="Para" id="Par42">To solve these problems, a service gives those pods a stable IP. In a more general sense, a <em class="EmphasisTypeItalic ">service</em> is an abstraction that defines a logical set of pods and a policy by which you have access to them. When a service is created, it publishes its own virtual address as an <span id="ITerm29">environment variable</span> to every pod. Services not only abstract access to pods, but they can also abstract access to DBs, external hosts, or even other services. A Kubernetes service is a resource you create to make a single, stable entry point to a group of pods providing the same service. Each service is an IP address and port combination that don’t change during the lifetime of the service. As shown in Figure <span class="InternalRef"><a href="#Fig5">10-5</a></span>, a Kubernetes <span id="ITerm30">service</span> can be backed by a single pod or many replicas of the same pod. External clients can reach any of the pods of the same service by a single service name. Similarly, a frontend pod or, for that matter a frontend service, can also reach any of the pods of the same backend service by a single service name. Figure <span class="InternalRef"><a href="#Fig5">10-5</a></span> shows two services—<span class="EmphasisFontCategoryNonProportional ">product-web</span> and <span class="EmphasisFontCategoryNonProportional ">product-server</span>.<figure class="Figure" id="Fig5"><div class="MediaObject" id="MO5"><img alt="" aria-describedby="d64e595" src="../images/619782_1_En_10_Chapter/Imagem-110.jpg" style="width:35.15em"/><div class="TextObject" id="d64e595"><p class="Para" id="Par198">A diagram illustrates an architecture for an e-commerce product web service. A user interacts with a browser, which sends requests to a product web microservice which consists of multiple product-web pods that communicate with a product server microservice with multiple product-server pods.</p></div></div><figcaption class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Figure 10-5</span><p class="SimplePara">Kubernetes services</p></div></figcaption></figure></div>

          <p class="Para" id="Par43">Here, the browser or the client device should know the <span id="ITerm31">service</span> (name) of the frontend microservice—the Product Web microservice. In a similar manner, the frontend microservice should know the service (name) of the backend microservice—the Product Server microservice.</p>

        </section>

      </section>

      <section class="Section1 RenderAsSection1" id="Sec13">

        <h2 class="Heading">Traffic Routing to Kubernetes</h2>

        <p class="Para" id="Par44">There are different ways to get external traffic into your Kubernetes cluster. This section looks at how each of them works.</p>

        <section class="Section2 RenderAsSection2" id="Sec14">

          <h3 class="Heading">Cluster IP</h3>

          <div class="Para" id="Par45">As the name implies, this provides access only inside the Kubernetes cluster. Other apps inside your cluster can access this, but there is no external access to the service. <span id="ITerm32">Cluster IP</span> is described in Listing <span class="InternalRef"><a href="#PC1">10-1</a></span>.<div class="ProgramCode" id="PC1"><div class="LineGroup"><div class="FixedLine">apiVersion: v1</div><div class="FixedLine">kind: Service</div><div class="FixedLine">metadata:</div><div class="FixedLine">  name: product-web</div><div class="FixedLine">spec:</div><div class="FixedLine">  selector:</div><div class="FixedLine">    app: product-web</div><div class="FixedLine">  type: ClusterIP</div><div class="FixedLine">  ports:</div><div class="FixedLine">  - name: http</div><div class="FixedLine">    port: 80</div><div class="FixedLine">    targetPort: 80</div><div class="FixedLine">    protocol: TCP</div></div><div class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Listing 10-1</span><p class="SimplePara">The <span id="ITerm33">ClusterIP Definition</span></p></div></div></div></div>

          <div class="Para" id="Par46">You might now wonder how you access the service externally? The answer is to use a Kubernetes proxy, as shown in Figure <span class="InternalRef"><a href="#Fig6">10-6</a></span>.<figure class="Figure" id="Fig6"><div class="MediaObject" id="MO6"><img alt="" aria-describedby="d64e682" src="../images/619782_1_En_10_Chapter/Imagem-111.jpg" style="width:35.15em"/><div class="TextObject" id="d64e682"><p class="Para" id="Par199">A diagram illustrates how a user interacts with a browser, which sends requests to a proxy server. The proxy server then forwards the requests to a kubernetes cluster running a product web microservice. The microservice consists of multiple product-web pods that handle the requests.</p></div></div><figcaption class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Figure 10-6</span><p class="SimplePara">Kubernetes proxy to ClusterIP</p></div></figcaption></figure></div>

          <div class="Para" id="Par47">You can start a Kubernetes <span id="ITerm34">proxy</span> with this command:<div class="ProgramCode" id="PC2"><div class="LineGroup"><div class="FixedLine">(base) binildass-MacBook-Pro:ch10-01 binil$ kubectl proxy --port=8080</div></div></div></div>

          <p class="Para" id="Par48">This will create a proxy server or application-level gateway between the localhost and the Kubernetes API server. All incoming data enters through one port and is forwarded to the remote Kubernetes API server port.</p>

        </section>

        <section class="Section2 RenderAsSection2" id="Sec15">

          <h3 class="Heading">NodePorts</h3>

          <p class="Para" id="Par49">When you expose the service as a NodePort service, each cluster node opens a port on the node itself (hence the name) and redirects traffic received on that port to the respective service. The service is not only accessible at the internal cluster IP and port, but also through a dedicated port on all nodes or virtual machines.</p>

          <div class="Para" id="Par50">A <span id="ITerm35">NodePort</span> is thus the most primitive way to get external traffic directly to your service. The definition of a NodePort is shown in Listing <span class="InternalRef"><a href="#PC3">10-2</a></span>.<div class="ProgramCode" id="PC3"><div class="LineGroup"><div class="FixedLine">apiVersion: v1</div><div class="FixedLine">kind: Service</div><div class="FixedLine">metadata:</div><div class="FixedLine">  name: product-server-nodeport</div><div class="FixedLine">spec:</div><div class="FixedLine">  selector:</div><div class="FixedLine">    app: product-server</div><div class="FixedLine">  ports:</div><div class="FixedLine">    - nodePort: 30002</div><div class="FixedLine">      port: 8081</div><div class="FixedLine">      targetPort: 8081</div><div class="FixedLine">  type: NodePort</div></div><div class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Listing 10-2</span><p class="SimplePara">The NodePort Definition</p></div></div></div></div>

          <p class="Para" id="Par51">In Listing <span class="InternalRef"><a href="#PC3">10-2</a></span>, <span class="EmphasisFontCategoryNonProportional ">30002</span> is specified as the nodePort. You can only use ports <span class="EmphasisFontCategoryNonProportional ">30000</span> to <span class="EmphasisFontCategoryNonProportional ">32767</span>, and if it’s not specified, a random port is used.</p>

          <div class="Para" id="Par52">As shown in Figure <span class="InternalRef"><a href="#Fig7">10-7</a></span>, since a service spans across nodes, a connection received on a port of the first node might be forwarded either to the pod running on the same first node or to one of the pods running on the other nodes.<figure class="Figure" id="Fig7"><div class="MediaObject" id="MO7"><img alt="" aria-describedby="d64e787" src="../images/619782_1_En_10_Chapter/Imagem-112.jpg" style="width:35.15em"/><div class="TextObject" id="d64e787"><p class="Para" id="Par200">A diagram illustrates how a user interacts with a browser, which sends requests to a load balancer that distributes traffic among multiple product-web pods within a kubernetes cluster. The pods run on virtual machines and communicate with each other on port 30000.</p></div></div><figcaption class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Figure 10-7</span><p class="SimplePara"><span id="ITerm36">Node port</span><span id="ITerm37"></span> in Kubernetes</p></div></figcaption></figure></div>

        </section>

        <section class="Section2 RenderAsSection2" id="Sec16">

          <h3 class="Heading">Load Balancer</h3>

          <div class="Para" id="Par53">Using a <span id="ITerm38">load balancer</span>, you can expose services to the Internet. This makes the service accessible through a dedicated load balancer, provisioned from the <span id="ITerm39">cloud infrastructure</span> that Kubernetes is running on. See Listing <span class="InternalRef"><a href="#PC4">10-3</a></span>.<div class="ProgramCode" id="PC4"><div class="LineGroup"><div class="FixedLine">apiVersion: v1</div><div class="FixedLine">kind: Service</div><div class="FixedLine">metadata:</div><div class="FixedLine">  name: product-web</div><div class="FixedLine">spec:</div><div class="FixedLine">  selector:</div><div class="FixedLine">    app: product-web</div><div class="FixedLine">  type: LoadBalancer</div><div class="FixedLine">  ports:</div><div class="FixedLine">    - port: 8765</div><div class="FixedLine">      targetPort: 80</div></div><div class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Listing 10-3</span><p class="SimplePara">The <span id="ITerm40">LoadBalancer</span> Definition</p></div></div></div></div>

          <div class="Para" id="Par54">When you use a load balancer, there is no routing or filtering, and all the traffic you specify will be forwarded to the service, as shown in Figure <span class="InternalRef"><a href="#Fig8">10-8</a></span>.<figure class="Figure" id="Fig8"><div class="MediaObject" id="MO8"><img alt="" aria-describedby="d64e865" src="../images/619782_1_En_10_Chapter/Imagem-113.jpg" style="width:26.58em"/><div class="TextObject" id="d64e865"><p class="Para" id="Par201">A diagram illustrates how a user interacts with a browser, which sends requests to a load balancer that distributes traffic to the product-web micro pods within a kubernetes cluster. The product-web has several product-web pods.</p></div></div><figcaption class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Figure 10-8</span><p class="SimplePara"><span id="ITerm41">Load balancer</span> in Kubernetes</p></div></figcaption></figure></div>

          <p class="Para" id="Par55">The downside of the load balancer is that each service you expose will get its own IP address, and you must pay for one load balancer each for all services exposed.</p>

        </section>

        <section class="Section2 RenderAsSection2" id="Sec17">

          <h3 class="Heading">Ingress</h3>

          <div class="Para" id="Par56">An <em class="EmphasisTypeItalic ">ingress</em> can expose multiple services through a single IP address. <span id="ITerm42">Ingress</span><span id="ITerm43"></span> operates at the HTTP level (network layer 7), so it’s cost efficient. There are many kinds of ingress with different capabilities. See Figure <span class="InternalRef"><a href="#Fig9">10-9</a></span>.<figure class="Figure" id="Fig9"><div class="MediaObject" id="MO9"><img alt="" aria-describedby="d64e900" src="../images/619782_1_En_10_Chapter/Imagem-114.jpg" style="width:35.15em"/><div class="TextObject" id="d64e900"><p class="Para" id="Par202">A diagram illustrates how a user interacts with a browser, which sends requests to a load balancer that distributes traffic among multiple product-web and stock-web pods within a kubernetes cluster. The pods communicate with each other using an ingress controller.</p></div></div><figcaption class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Figure 10-9</span><p class="SimplePara">Ingress in Kubernetes</p></div></figcaption></figure></div>

          <div class="Para" id="Par57">Listing <span class="InternalRef"><a href="#PC5">10-4</a></span> defines an ingress with two rules.<div class="ProgramCode" id="PC5"><div class="LineGroup"><div class="FixedLine">apiVersion: networking.k8s.io/v1</div><div class="FixedLine">kind: Ingress</div><div class="FixedLine">metadata:</div><div class="FixedLine">  name: ingress-service</div><div class="FixedLine">  annotations:</div><div class="FixedLine">    kubernetes.io/ingress.class: nginx</div><div class="FixedLine">spec:</div><div class="FixedLine">  rules:</div><div class="FixedLine">    - host: "adminer.acme.test"</div><div class="FixedLine">      http:</div><div class="FixedLine">        paths:</div><div class="FixedLine">          - path: /</div><div class="FixedLine">            pathType: Prefix</div><div class="FixedLine">            backend:</div><div class="FixedLine">              service:</div><div class="FixedLine">                name: adminer</div><div class="FixedLine">                port:</div><div class="FixedLine">                  number: 8080</div><div class="FixedLine">    - host: "products.acme.test"</div><div class="FixedLine">      http:</div><div class="FixedLine">        paths:</div><div class="FixedLine">          - path: /</div><div class="FixedLine">            pathType: Prefix</div><div class="FixedLine">            backend:</div><div class="FixedLine">              service:</div><div class="FixedLine">                name: product-web</div><div class="FixedLine">                port:</div><div class="FixedLine">                  number: 8080</div></div><div class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Listing 10-4</span><p class="SimplePara">The Ingress <span id="ITerm44">Definition</span></p></div></div></div></div>

          <p class="Para" id="Par58">The rules in Listing <span class="InternalRef"><a href="#PC5">10-4</a></span> ensure that all HTTP requests received by the Ingress controller, in which the <span class="EmphasisFontCategoryNonProportional ">products.acme.test</span> host is requested, will be sent to the <span class="EmphasisFontCategoryNonProportional ">product-web</span> service on port <span class="EmphasisFontCategoryNonProportional ">8080</span> and that all HTTP requests in which the <span class="EmphasisFontCategoryNonProportional ">adminer.acme.test</span> host is requested will be sent to the adminer service on port <span class="EmphasisFontCategoryNonProportional ">8080</span>.</p>

        </section>

      </section>

      <section class="Section1 RenderAsSection1" id="Sec18">

        <h2 class="Heading">State Management</h2>

        <p class="Para" id="Par59">When you look at pods and deployments in detail, you know that <span id="ITerm45">Kubernetes pods</span> are to be designed for scaling out, even elastically. There is a downside to scaling architectures.</p>

        <section class="Section2 RenderAsSection2" id="Sec19">

          <h3 class="Heading">Scale Out vs. State Management</h3>

          <p class="Para" id="Par60">Although it is desirable to have <span id="ITerm46">elastic scale out architectures</span>, state management poses issues. If the components are to be truly stateless, they are to be like “tellers in a bank” in the sense that you are not served by the same teller (person) every time. Similarly, every subsequent transaction could be served by any other instance of the similar component. This means, except your client device and your persistent store, every other intermediate component must be stateless. You cannot avoid state in the client tier, since then you cannot do any personalization, which will inhibit user experience. Similarly, for non-trivial applications, some kind of state has to be managed and you would typically do that in some kind of database.</p>

        </section>

        <section class="Section2 RenderAsSection2" id="Sec20">

          <h3 class="Heading">StatefulSets</h3>

          <div class="Para" id="Par61">To solve the issue of state management, a <span id="ITerm47"><em class="EmphasisTypeItalic ">StatefulSet</em></span> represents a set of pods that are unique, persistent, and have a stable pod name (see Figure <span class="InternalRef"><a href="#Fig10">10-10</a></span>). In the case of the non-stateful DeploymentSet, whenever you deploy a pod, upon every deployment or restart you will get a different pod name—something like <span class="EmphasisFontCategoryNonProportional ">product-server-6fb88b6849-6mrf5</span> or <span class="EmphasisFontCategoryNonProportional ">product-web-5dfc886d6d-zvm8p</span>. In such cases, the pod name will change when it restarts. And on the next restart, it could be anything, like <span class="EmphasisFontCategoryNonProportional ">product-web-5dfc886d6d-4qw45</span> or <span class="EmphasisFontCategoryNonProportional ">product-server-6fb88b6849-dwkcf</span>. If you want a stable pod name, a StatefulSet can be used. Then, even when the deployment restarts, you will get the same pod name (such as <span class="EmphasisFontCategoryNonProportional ">mongo-cluster-0</span>).<figure class="Figure" id="Fig10"><div class="MediaObject" id="MO10"><img alt="" aria-describedby="d64e1067" src="../images/619782_1_En_10_Chapter/Imagem-115.jpg" style="width:35.15em"/><div class="TextObject" id="d64e1067"><p class="Para" id="Par203">A diagram illustrates how a user interacts with a laptop, which sends requests to the persistence service. The service consists of multiple persistent pods that utilize persistent volume claims to access persistent volumes on underlying nodes. The P Vs are provisioned based on a storage class.</p></div></div><figcaption class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Figure 10-10</span><p class="SimplePara">Kubernetes <span id="ITerm48">stateful sets</span></p></div></figcaption></figure></div>

        </section>

        <section class="Section2 RenderAsSection2" id="Sec21">

          <h3 class="Heading">Persistent Volume Claim</h3>

          <p class="Para" id="Par62">A <em class="EmphasisTypeItalic ">persistent volume claim</em> <span id="ITerm49">(PVC)</span> is a declaration by the pod for a need for storage that can at some point in the lifecycle of the pod become available or satisfied. A persistent volume claim promises that it will at some point “translate” into some platform specific storage volume that your <span id="ITerm50">application</span> will be able to use, with one of defined characteristics, such as class, size, and access mode (<span class="EmphasisFontCategoryNonProportional ">ROX</span>: ReadOnlyMany, <span class="EmphasisFontCategoryNonProportional ">RWO</span>: ReadWriteOnce, and <span class="EmphasisFontCategoryNonProportional ">RWX</span>: ReadWriteMany).</p>

          <p class="Para" id="Par63">In this manner you can abstract linking of a particular storage implementation away from your pods/deployments. Your application in typical cases specify something like “I need persistent storage of default class and size Y.” Later, during the time when the “promise” is fulfilled at runtime, you can link an EBS device, an EFS store, and so on, and your core manifests are the same in both cases.</p>

        </section>

        <section class="Section2 RenderAsSection2" id="Sec22">

          <h3 class="Heading">Persistent Volume</h3>

          <p class="Para" id="Par64">A <em class="EmphasisTypeItalic ">persistent volume</em> <span id="ITerm51">(PV)</span> is a piece of storage in the Kubernetes cluster that has been provisioned by the server/storage/cluster administrator or dynamically provisioned using some storage classes. It is a resource in the cluster just like a node. So, the persistent volume is the actual product or options that you get back from Kubernetes that you asked for. If Kubernetes does not have what you asked for, it will try to create it on the fly for you.</p>

          <p class="Para" id="Par65">In the section illustrating the first example in this chapter, especially in Listings <span class="InternalRef"><a href="#PC12">10-11</a></span> through <span class="InternalRef"><a href="#PC15">10-14</a></span>, you will come across how all these concepts of state management are affected with running examples.</p>

        </section>

      </section>

      <section class="Section1 RenderAsSection1" id="Sec23">

        <h2 class="Heading">Kubernetes Clusters</h2>

        <p class="Para" id="Par66">As you have seen, a Kubernetes cluster is a set of nodes that run containerized applications. <span id="ITerm52">Kubernetes clusters</span> allow containers to run across multiple machines and environments—virtual, physical, cloud-based, or on-premises. Creating a Kubernetes cluster from scratch is a non-trivial task. Adding to the complexity, there are multiple options and tools to select from.</p>

        <p class="Para" id="Par67">As an easier path, there is <span id="ITerm53">Minikube</span><span id="ITerm54"></span>, which is a local Kubernetes tool, focusing on making it easy to learn and develop for Kubernetes. You do need other and better options to run production workloads.</p>

        <section class="Section2 RenderAsSection2" id="Sec24">

          <h3 class="Heading">Minikube</h3>

          <p class="Para" id="Par68">As stated, Minikube is local Kubernetes. It is rather easy to set up a single-node, local Kubernetes using Minikube. Moreover, a local Kubernetes will also speed up the cycle time of code, test, deploy, and debug cycle on the developer machine before you commit changes to your teams environment. Minikube will also enable developers to develop and test containerized applications in Windows and Mac environments, which are the preferred development machine OSes among application developers.</p>

          <p class="Para" id="Par69">Appendix E on container tools provides detailed instructions to install and bring up Minikube in a Mac environment.</p>

          <p class="Para" id="Par70">The next section gets into some code. You will deploy the first application into a <span id="ITerm55">Minikube-based local Kubernetes</span> cluster.</p>

        </section>

      </section>

      <section class="Section1 RenderAsSection1" id="Sec25">

        <h2 class="Heading">Microservices and MongoDB in Kubernetes</h2>

        <p class="Para" id="Par71">This example reuses the microservices from the section titled “Microservices Using MongoDB and <span id="ITerm56">CrudRepository</span>” in Chapter <span class="ExternalRef"><a href="Capítulo-05.html"><span class="RefSource">3</span></a></span>. It uses the same two microservices—a consumer and a provider microservice communicating with each other using the REST protocol. The provider microservice also interacts with a MongoDB. You will use volumes to persist the Mongo database data. Refer to Figure <span class="ExternalRef"><a href="Capítulo-04.html#Fig1"><span class="RefSource">2-1</span></a></span> in Chapter <span class="ExternalRef"><a href="Capítulo-04.html"><span class="RefSource">2</span></a></span> for the overall design.</p>

        <section class="Section2 RenderAsSection2" id="Sec26">

          <h3 class="Heading">Design Microservices Deployment Topology</h3>

          <p class="Para" id="Par72">This example reuses the deployment schema defined in the second example in Chapter <span class="ExternalRef"><a href="Capítulo-11.html"><span class="RefSource">9</span></a></span>, shown in Figure <span class="ExternalRef"><a href="Capítulo-04.html#Fig2"><span class="RefSource">9-2</span></a></span>. The one change is that this example uses Kubernetes.</p>

          <div class="Para" id="Par73">The deployment topology of the microservices is shown in Figure <span class="InternalRef"><a href="#Fig11">10-11</a></span>.<figure class="Figure" id="Fig11"><div class="MediaObject" id="MO11"><img alt="" aria-describedby="d64e1222" src="../images/619782_1_En_10_Chapter/Imagem-116.jpg" style="width:35.15em"/><div class="TextObject" id="d64e1222"><p class="Para" id="Par204">A diagram illustrates how a user interacts with a browser, which sends requests to a product web microservice. The microservice has multiple product-web pods that communicate with a product server microservice. It utilizes a mongo D B which is deployed on a kubernetes cluster by minikube and docker.</p></div></div><figcaption class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Figure 10-11</span><p class="SimplePara">Kubernetes-based deployment topology for microservices</p></div></figcaption></figure></div>

          <p class="Para" id="Par74">Here, the <span id="ITerm57">Product Web and Product Server</span> containers provide business services, whereas the Mongo container provides application services for persisting state.</p>

        </section>

        <section class="Section2 RenderAsSection2" id="Sec27">

          <h3 class="Heading">Understanding the Source Code</h3>

          <p class="Para" id="Par75">The <span id="ITerm58">source code</span> for this book is available on GitHub via the book’s product page, located at <span class="ExternalRef"><a href="http://www.apress.com/9798868805547"><span class="RefSource"><span class="EmphasisFontCategoryNonProportional ">www.apress.com/9798868805547</span></span></a></span>. The source code for the example is organized inside the <span class="EmphasisFontCategoryNonProportional ">ch10\ch10-01</span> folder. Much of the source code in this example is similar to <span class="EmphasisFontCategoryNonProportional ">ch03\ch03-02</span>, which was explained in detail in Chapter <span class="ExternalRef"><a href="Capítulo-05.html"><span class="RefSource">3</span></a></span>, in the section titled “Microservices Using MongoDB and CrudRepository.” You also saw the Docker-based deployment of the topology in Figure <span class="ExternalRef"><a href="Capítulo-10.html#Fig9"><span class="RefSource">8-9</span></a></span>, in the section titled “Microservice and MongoDB Containers Using File Mount” in Chapter <span class="ExternalRef"><a href="Capítulo-10.html"><span class="RefSource">8</span></a></span>. The Docker Compose-based deployment of the topology was also shown in Figure <span class="ExternalRef"><a href="Capítulo-11.html#Fig2"><span class="RefSource">9-2</span></a></span>, in the section titled “Composing Microservice with MongoDB Containers” in Chapter <span class="ExternalRef"><a href="Capítulo-11.html"><span class="RefSource">9</span></a></span>. For those reasons, this section gets right into the Kubernetes-specific aspects.</p>

          <div class="Para" id="Par76">A summarized representation of the source code organization for the example inside the <span class="EmphasisFontCategoryNonProportional ">ch10-01</span> folder is shown in Listing <span class="InternalRef"><a href="#PC6">10-5</a></span>.<div class="ProgramCode" id="PC6"><div class="LineGroup"><div class="FixedLine">./ch10-01/</div><div class="FixedLine">├── 01-ProductServer</div><div class="FixedLine">│   ├── pom.xml</div><div class="FixedLine">│   └── src</div><div class="FixedLine">│       └── ...</div><div class="FixedLine">├── 02-ProductWeb</div><div class="FixedLine">│   ├── pom.xml</div><div class="FixedLine">│   └── src</div><div class="FixedLine">│       └── ...</div><div class="FixedLine">├── Dockerfile</div><div class="FixedLine">├── README.txt</div><div class="FixedLine">├── clean.sh</div><div class="FixedLine">├── makeandrun.sh</div><div class="FixedLine">├── mongo-deployment.yml</div><div class="FixedLine">├── mongo-service.yml</div><div class="FixedLine">├── mongo-volume-claim.yml</div><div class="FixedLine">├── mongo-volume.yml</div><div class="FixedLine">├── pom.xml</div><div class="FixedLine">├── product-server-deployment.yml</div><div class="FixedLine">├── product-server-service.yml</div><div class="FixedLine">├── product-web-deployment.yml</div><div class="FixedLine">└── product-web-service.yml</div></div><div class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Listing 10-5</span><p class="SimplePara">Example 10-01 <span id="ITerm59">Source Code</span> Organization</p></div></div></div></div>

          <p class="Para" id="Par77">This <span id="ITerm60">Dockerfile</span> is like the one from the section titled “Build Microservice Using Dockerfile” of Chapter <span class="ExternalRef"><a href="Capítulo-09.html"><span class="RefSource">7</span></a></span>, so I do not repeat the explanation here. There are a set of <span class="EmphasisFontCategoryNonProportional ">.yml</span> files as well.</p>

          <p class="Para" id="Par78">Creating the Kubernetes <span id="ITerm61">resources</span> is done by posting a JSON or YAML manifest to the Kubernetes’s REST endpoint. This helps to version-control these resource definitions.</p>

          <p class="Para" id="Par79">The first resource I investigate is a pod, which is a collocated group of containers. It represents the basic building block in Kubernetes. You always deploy and operate on a pod of containers. It’s very common for pods to contain only a single container, but if you think you have closely related containers, you may have more than one container in a pod. Sidecar containers are one such example, where a log and a data change watcher can be in the same pod of the main container.</p>

          <div class="Para" id="Par80">Subsequently, even though you can host a multi-tier application (such as <span class="EmphasisFontCategoryNonProportional ">ProductWeb</span> and <span class="EmphasisFontCategoryNonProportional ">ProductServer</span>) in a single pod, the recommended way is to use separate pods for each tier. The reason for that is simple—you can scale out tiers independently and distribute them across clusters. See Listing <span class="InternalRef"><a href="#PC7">10-6</a></span>.<div class="ProgramCode" id="PC7"><div class="LineGroup"><div class="FixedLine">---</div><div class="FixedLine">apiVersion: apps/v1</div><div class="FixedLine">kind: Deployment</div><div class="FixedLine">metadata:</div><div class="FixedLine">  name: product-web</div><div class="FixedLine">  labels:</div><div class="FixedLine">    app: product-web</div><div class="FixedLine">    group: frontend</div><div class="FixedLine">spec:</div><div class="FixedLine">  replicas: 1</div><div class="FixedLine">  selector:</div><div class="FixedLine">    matchLabels:</div><div class="FixedLine">      app: product-web</div><div class="FixedLine">  template:</div><div class="FixedLine">    metadata:</div><div class="FixedLine">      labels:</div><div class="FixedLine">        app: product-web</div><div class="FixedLine">    spec:</div><div class="FixedLine">      containers:</div><div class="FixedLine">      - name: product-web</div><div class="FixedLine">        image: ecom/product-web</div><div class="FixedLine">        ports:</div><div class="FixedLine">        - containerPort: 8080</div><div class="FixedLine">        imagePullPolicy: Never</div><div class="FixedLine">        env:</div><div class="FixedLine">          - name: acme.PRODUCT_SERVICE_URL</div><div class="FixedLine">            value: http://product-server:8081/products</div></div><div class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Listing 10-6</span><p class="SimplePara">The <span id="ITerm62">Pod Definition YAML File</span> for Product Web (ch10\ch10-01\product-web-deployment.yml)</p></div></div></div></div>

          <p class="Para" id="Par81">In the pod definition in Listing <span class="InternalRef"><a href="#PC7">10-6</a></span>, the first line is a separator, and it is optional. If you’re trying to define multiple structures in a single file, the separator is required. The metadata contains the name, namespace, labels, and other information about the <span id="ITerm63">Kubernetes pod</span>.</p>

          <p class="Para" id="Par82">Listing <span class="InternalRef"><a href="#PC7">10-6</a></span> shows the pod descriptor for the Product Web microservice. Here, <span class="EmphasisFontCategoryNonProportional ">Spec</span> includes the actual description of the Kubernetes pod’s contents, such as the pod’s containers, number of replicas, the image, volumes, and other data.</p>

          <p class="Para" id="Par83">Note the <span class="EmphasisFontCategoryNonProportional ">containerPort: 8080</span>. Even if you don’t assign a port, clients can still connect to the pod. If the app binds to <span class="EmphasisFontCategoryNonProportional ">127.0.0.1</span>, it will effectively prevent traffic to the pod, whereas <span class="EmphasisFontCategoryNonProportional ">0.0.0.0</span> allows traffic to the pod on all interfaces, even if the port isn’t listed in the pod spec explicitly. But if you define the ports explicitly, everyone using your cluster can quickly see which ports each pod exposes. Explicitly defining ports also allows you to assign a name to each port, which can be handy.</p>

          <p class="Para" id="Par84">The <span id="ITerm64">Product Web microservice</span> is dependent on the appropriate value for an environment variable <span class="EmphasisFontCategoryNonProportional ">acme.PRODUCT_SERVICE_URL</span>, whose value you set as the service URL for the dependent Product Server microservice, which you will see in Listing <span class="InternalRef"><a href="#PC10">10-9</a></span>.</p>

          <div class="Para" id="Par85">In the same manner you created a pod, the easiest way to create a Kubernetes service is to post a JSON or YAML manifest to the Kubernetes’s <span id="ITerm65">REST</span> endpoint, as shown by the Kubernetes service of the Product Web microservice in Listing <span class="InternalRef"><a href="#PC8">10-7</a></span>.<div class="ProgramCode" id="PC8"><div class="LineGroup"><div class="FixedLine">apiVersion: v1</div><div class="FixedLine">kind: Service</div><div class="FixedLine">metadata:</div><div class="FixedLine">  name: product-web</div><div class="FixedLine">spec:</div><div class="FixedLine">  selector:</div><div class="FixedLine">    app: product-web</div><div class="FixedLine">  ports:</div><div class="FixedLine">    - protocol: TCP</div><div class="FixedLine">      port: 8080</div><div class="FixedLine">      targetPort: 8080</div><div class="FixedLine">  type: LoadBalancer</div></div><div class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Listing 10-7</span><p class="SimplePara">The Service Definition YAML File for Product Web (ch10\ch10-01\product-web-service.yml)</p></div></div></div></div>

          <p class="Para" id="Par86">In Listing <span class="InternalRef"><a href="#PC8">10-7</a></span>, the service has a name, <span class="EmphasisFontCategoryNonProportional ">product-web</span>. The <span class="EmphasisFontCategoryNonProportional ">port</span> refers to which port this service will be available on and the <span class="EmphasisFontCategoryNonProportional ">targetPort</span> is the container port to which the request will be forwarded, to avail the service. So, to summarize, you’re defining a service called <span class="EmphasisFontCategoryNonProportional ">product-web</span>, which will accept requests on port <span class="EmphasisFontCategoryNonProportional ">80</span> and route each request to port <span class="EmphasisFontCategoryNonProportional ">8080</span> of one of the pods matching the <span class="EmphasisFontCategoryNonProportional ">app=product-web</span> label selector. You can also see that a <span class="EmphasisFontCategoryNonProportional ">LoadBalancer</span> is defined for easy access to the services.</p>

          <div class="Para" id="Par87">Listing <span class="InternalRef"><a href="#PC9">10-8</a></span> shows the pod description for the Product Server microservice.<div class="ProgramCode" id="PC9"><div class="LineGroup"><div class="FixedLine">apiVersion: apps/v1</div><div class="FixedLine">kind: Deployment</div><div class="FixedLine">metadata:</div><div class="FixedLine">  name: product-server</div><div class="FixedLine">  labels:</div><div class="FixedLine">    app: product-server</div><div class="FixedLine">    group: backend</div><div class="FixedLine">spec:</div><div class="FixedLine">  replicas: 1</div><div class="FixedLine">  selector:</div><div class="FixedLine">    matchLabels:</div><div class="FixedLine">      app: product-server</div><div class="FixedLine">  template:</div><div class="FixedLine">    metadata:</div><div class="FixedLine">      labels:</div><div class="FixedLine">        app: product-server</div><div class="FixedLine">    spec:</div><div class="FixedLine">      containers:</div><div class="FixedLine">      - name: product-server</div><div class="FixedLine">        image: ecom/product-server</div><div class="FixedLine">        ports:</div><div class="FixedLine">        - containerPort: 8081</div><div class="FixedLine">        imagePullPolicy: Never</div><div class="FixedLine">        env:</div><div class="FixedLine">          - name: spring.data.mongodb.uri</div><div class="FixedLine">          value: mongodb://mongo:27017/test</div></div><div class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Listing 10-8</span><p class="SimplePara">The <span id="ITerm66">Pod Definition YAML File</span> for Product Server (ch10\ch10-01\product-server-deployment.yml)</p></div></div></div></div>

          <p class="Para" id="Par88">One notable aspect here is that the Product Server microservice is dependent on the appropriate value for an environment variable <span class="EmphasisFontCategoryNonProportional ">spring.data.mongodb.uri</span>, whose value is set as the service URL for the dependent Mongo DB, which you will see in Listing <span class="InternalRef"><a href="#PC16">10-15</a></span>.</p>

          <div class="Para" id="Par89">Listing <span class="InternalRef"><a href="#PC10">10-9</a></span> shows the service description for the <span id="ITerm67">Product Server microservice</span>.<div class="ProgramCode" id="PC10"><div class="LineGroup"><div class="FixedLine">apiVersion: v1</div><div class="FixedLine">kind: Service</div><div class="FixedLine">metadata:</div><div class="FixedLine">  name: product-server</div><div class="FixedLine">spec:</div><div class="FixedLine">  selector:</div><div class="FixedLine">     app: product-server</div><div class="FixedLine">  ports:</div><div class="FixedLine">    - protocol: TCP</div><div class="FixedLine">      port: 8081</div><div class="FixedLine">      targetPort: 8081</div></div><div class="LineGroup"><div class="FixedLine">---</div></div><div class="LineGroup"><div class="FixedLine">apiVersion: v1</div><div class="FixedLine">kind: Service</div><div class="FixedLine">metadata:</div><div class="FixedLine">  name: product-server-nodeport</div><div class="FixedLine">spec:</div><div class="FixedLine">  selector:</div><div class="FixedLine">    app: product-server</div><div class="FixedLine">  ports:</div><div class="FixedLine">    - nodePort: 30002</div><div class="FixedLine">      port: 8081</div><div class="FixedLine">      targetPort: 8081</div><div class="FixedLine">  type: NodePort</div></div><div class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Listing 10-9</span><p class="SimplePara">The Service Definition YAML File for Product Server (ch10\ch10-01\product-server-service.yml)</p></div></div></div></div>

          <p class="Para" id="Par90">There is no need for the <span id="ITerm68">Product Server microservice</span> to be accessed by any external clients, so I omitted the <span class="EmphasisFontCategoryNonProportional ">LoadBalancer</span> type of service definition, which you saw in Listing <span class="InternalRef"><a href="#PC8">10-7</a></span> for Product Web microservice. A <span class="EmphasisFontCategoryNonProportional ">ClusterIP</span> would have been enough, but an additional <span class="EmphasisFontCategoryNonProportional ">NodePort</span> was defined, the advantage of which I explain in the “Test the Microservices” section.</p>

          <div class="Para" id="Par91">The third component in Figure <span class="InternalRef"><a href="#Fig11">10-11</a></span> is the MongoDB. Listing <span class="InternalRef"><a href="#PC11">10-10</a></span> shows the pod definition for the MongoDB.<div class="ProgramCode" id="PC11"><div class="LineGroup"><div class="FixedLine">apiVersion: apps/v1</div><div class="FixedLine">kind: StatefulSet</div><div class="FixedLine">metadata:</div><div class="FixedLine">  name: mongo-cluster</div><div class="FixedLine">  labels:</div><div class="FixedLine">    app: mongo</div><div class="FixedLine">spec:</div><div class="FixedLine">  replicas: 1</div><div class="FixedLine">  serviceName: "mongo"</div><div class="FixedLine">  selector:</div><div class="FixedLine">    matchLabels:</div><div class="FixedLine">      app: mongo</div><div class="FixedLine">  template:</div><div class="FixedLine">    metadata:</div><div class="FixedLine">      labels:</div><div class="FixedLine">        app: mongo</div><div class="FixedLine">      annotations:</div><div class="FixedLine">        sidecar.istio.io/inject: "false"</div><div class="FixedLine">    spec:</div><div class="FixedLine">      volumes:</div><div class="FixedLine">        - name: data-db</div><div class="FixedLine">          persistentVolumeClaim:</div><div class="FixedLine">            claimName: mongo-data-db</div><div class="FixedLine">      terminationGracePeriodSeconds: 10</div><div class="FixedLine">      containers:</div><div class="FixedLine">        - name: mongo</div><div class="FixedLine">          image: mongo:4.2.24</div><div class="FixedLine">          volumeMounts:</div><div class="FixedLine">            - mountPath: /data/db</div><div class="FixedLine">              name: data-db</div><div class="FixedLine">              readOnly: false</div><div class="FixedLine">          ports:</div><div class="FixedLine">            - containerPort: 27017</div></div><div class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Listing 10-10</span><p class="SimplePara">The Pod Definition YAML File for MongoDB Server (ch10\ch10-01\mongo-deployment.yml)</p></div></div></div></div>

          <div class="Para" id="Par92">This example specifies using <span class="EmphasisFontCategoryNonProportional ">mongo:4.2.24</span> as the image based on which the pod is created. Note that the pod is defined as a <span class="EmphasisFontCategoryNonProportional ">StatefulSet</span>. The Mongo pod has to manage data or state in the MongoDB, so you need a stateful set. It also defines a <span class="EmphasisFontCategoryNonProportional ">persistentVolumeClaim</span>—<span class="EmphasisFontCategoryNonProportional ">mongo-data-db</span>. The next section looks at the description of this PVC.<div class="ProgramCode" id="PC12"><div class="LineGroup"><div class="FixedLine">apiVersion: v1</div><div class="FixedLine">kind: PersistentVolumeClaim</div><div class="FixedLine">metadata:</div><div class="FixedLine">  name: mongo-data-db</div><div class="FixedLine">spec:</div><div class="FixedLine">  storageClassName: manual</div><div class="FixedLine">  accessModes:</div><div class="FixedLine">    - ReadWriteOnce</div><div class="FixedLine">  resources:</div><div class="FixedLine">    requests:</div><div class="FixedLine">      storage: 3Gi</div></div><div class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Listing 10-11</span><p class="SimplePara">The <span id="ITerm69">Persistent Volume Claim Definition</span> for MongoDB (ch10\ch10-01\mongo-volume-claim.yml)</p></div></div></div></div>

          <div class="Para" id="Par93">Now you create the <span id="ITerm70"><span class="EmphasisFontCategoryNonProportional ">PersistentVolumeClaim</span></span>. The MongoDB pod uses <span class="EmphasisFontCategoryNonProportional ">PersistentVolumeClaim</span> to request physical storage. You request a volume of at least 3GB, so it can provide read-write access for at least one node. Once you execute the scripts in the next section, you can inspect the <span class="EmphasisFontCategoryNonProportional ">PersistentVolumeClaim</span>, as shown in Listing <span class="InternalRef"><a href="#PC13">10-12</a></span>.<div class="ProgramCode" id="PC13"><div class="LineGroup"><div class="FixedLine">(base) binildass-MacBook-Pro:~ binil$ kubectl get pvc mongo-data-db</div><div class="FixedLine">NAME            STATUS   VOLUME          CAPACITY   ACCESS MODES   STORAGECLASS   AGE</div><div class="FixedLine">mongo-data-db   Bound    mongo-data-db   10Gi       RWO            manual         2m32s</div><div class="FixedLine">(base) binildass-MacBook-Pro:~ binil$</div></div><div class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Listing 10-12</span><p class="SimplePara">Listing the Details of the Persistent Volume Claim</p></div></div></div></div>

          <div class="Para" id="Par94">Once you create the <span class="EmphasisFontCategoryNonProportional ">PersistentVolumeClaim</span>, the Kubernetes Control Plane looks for a <span class="EmphasisFontCategoryNonProportional ">PersistentVolume</span> that satisfies the claim’s requirements. See Listing <span class="InternalRef"><a href="#PC14">10-13</a></span>.<div class="ProgramCode" id="PC14"><div class="LineGroup"><div class="FixedLine">apiVersion: v1</div><div class="FixedLine">kind: PersistentVolume</div><div class="FixedLine">metadata:</div><div class="FixedLine">  name: mongo-data-db</div><div class="FixedLine">  labels:</div><div class="FixedLine">    type: local</div><div class="FixedLine">spec:</div><div class="FixedLine">  storageClassName: manual</div><div class="FixedLine">  capacity:</div><div class="FixedLine">    storage: 10Gi</div><div class="FixedLine">  accessModes:</div><div class="FixedLine">    - ReadWriteOnce</div><div class="FixedLine">  hostPath:</div><div class="FixedLine">    path: "/home/docker/binil/mongodata"</div></div><div class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Listing 10-13</span><p class="SimplePara">The Persistent Volume Definition for <span id="ITerm71">MongoDB</span> (ch10\ch10-01\mongo-volume.yml)</p></div></div></div></div>

          <div class="Para" id="Par95">With this, the Control Plane can find this <span id="ITerm72"><span class="EmphasisFontCategoryNonProportional ">PersistentVolum</span></span><span class="EmphasisFontCategoryNonProportional ">e</span> with the same storage class using the <span class="EmphasisFontCategoryNonProportional ">storageClassName</span>, so it binds the claim to the volume. After you execute the scripts in the next section, you can inspect the <span class="EmphasisFontCategoryNonProportional ">PersistentVolume</span>, as shown in Listing <span class="InternalRef"><a href="#PC15">10-14</a></span>.<div class="ProgramCode" id="PC15"><div class="LineGroup"><div class="FixedLine">(base) binildass-MacBook-Pro:~ binil$ kubectl get pv mongo-data-db</div><div class="FixedLine">NAME          CAPACITY ACCESS MODES RECLAIM STATUS CLAIM         STORAGECLASS              AGE</div><div class="FixedLine">mongo-data-db 10Gi     RWO          Retain  Bound  mongo-data-db manual      44s</div><div class="FixedLine">(base) binildass-MacBook-Pro:~ binil$</div></div><div class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Listing 10-14</span><p class="SimplePara">Listing the Details of the Persistent Volume</p></div></div></div></div>

          <p class="Para" id="Par96">As far as Kubernetes knows, <span class="EmphasisFontCategoryNonProportional ">mongo-data-db</span> PV is just some piece of storage somewhere and its lifecycle is independent on the pod that’s using it. So, even if the pod goes away—say it crashes or hits a memory limit and is killed due to an Out of Memory error—the storage is still there, ready to be used by your MongoDB pod when it regenerates. So this persistent volume will persist no matter what happens with the pod (sort of), since the <span class="EmphasisFontCategoryNonProportional ">RECLAIM</span> policy is <span class="EmphasisFontCategoryNonProportional ">Retain</span>, as you can see in Listing <span class="InternalRef"><a href="#PC15">10-14</a></span>. When the PVC is deleted, Kubernetes will handle the PV according to the <span class="EmphasisFontCategoryNonProportional ">RECLAIM</span> policy of the PV.</p>

          <div class="Para" id="Par97">The last aspect left is defining the <span id="ITerm73">MongoDB service</span>, which is done in Listing <span class="InternalRef"><a href="#PC16">10-15</a></span>.<div class="ProgramCode" id="PC16"><div class="LineGroup"><div class="FixedLine">apiVersion: v1</div><div class="FixedLine">kind: Service</div><div class="FixedLine">metadata:</div><div class="FixedLine">  name: mongo</div><div class="FixedLine">spec:</div><div class="FixedLine">  selector:</div><div class="FixedLine">    app: mongo</div><div class="FixedLine">  ports:</div><div class="FixedLine">    - protocol: TCP</div><div class="FixedLine">      port: 27017</div><div class="FixedLine">      targetPort: 27017</div></div><div class="LineGroup"><div class="FixedLine">---</div></div><div class="LineGroup"><div class="FixedLine">apiVersion: v1</div><div class="FixedLine">kind: Service</div><div class="FixedLine">metadata:</div><div class="FixedLine">  name: mongo-nodeport</div><div class="FixedLine">spec:</div><div class="FixedLine">  selector:</div><div class="FixedLine">     app: mongo</div><div class="FixedLine">  ports:</div><div class="FixedLine">    - nodePort: 30001</div><div class="FixedLine">      port: 27017</div><div class="FixedLine">      targetPort: 27017</div><div class="FixedLine">  type: NodePort</div></div><div class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Listing 10-15</span><p class="SimplePara">The Description for MongoDB Service (ch10\ch10-01\mongo-service.yml)</p></div></div></div></div>

          <p class="Para" id="Par98">As with the Product Server Service description in Listing <span class="InternalRef"><a href="#PC10">10-9</a></span>, a <span class="EmphasisFontCategoryNonProportional ">ClusterIP</span> would have been enough, but this example defined an additional <span class="EmphasisFontCategoryNonProportional ">NodePort</span>, the advantage of which I explain in the “Test the Microservices” section.</p>

        </section>

        <section class="Section2 RenderAsSection2" id="Sec28">

          <h3 class="Heading">Run Microservices in Kubernetes</h3>

          <div class="Para" id="Par99">The <span class="EmphasisFontCategoryNonProportional ">ch10\ch10-01</span> folder contains the scripts required to build and run the examples. The first step is to start a Minikube single-node Kubernetes cluster. Refer to Appendix E for a quick reference to the <span id="ITerm74">Kubernetes setup</span> and commands. See Listing <span class="InternalRef"><a href="#PC17">10-16</a></span>.<div class="ProgramCode" id="PC17"><div class="LineGroup"><div class="FixedLine">(base) binildass-MacBook-Pro:~ binil$ pwd</div><div class="FixedLine">/Users/binil</div><div class="FixedLine">(base) binildass-MacBook-Pro:~ binil$ minikube start</div><div class="FixedLine">  minikube v1.25.2 on Darwin 12.4</div><div class="FixedLine">...</div><div class="FixedLine">  Done! kubectl is now configured to use "minikube" cluster and "default" namespace by default</div><div class="FixedLine">(base) binildass-MacBook-Pro:~ binil$</div></div><div class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Listing 10-16</span><p class="SimplePara">Starting <span id="ITerm75">Minikube</span></p></div></div></div></div>

          <p class="Para" id="Par100">You must also set the Minikube environment variables in your work terminal.</p>

          <div class="FormalPara FormalParaRenderingStyle1 ParaTypeImportant" id="FPar1">

            <div class="Heading">Note</div>

            <p class="Para FirstParaInFormalPara" id="Par101">For all the examples in this chapter, I assume that the previous two steps connected to the Docker Daemon have been executed if you are using the Minikube single-node Kubernetes cluster.</p>

          </div>

          <div class="Para" id="Par102">As the next step, you need to create this new folder for Mongo data you configured in <span class="EmphasisFontCategoryNonProportional ">mongo-volume.yml</span>. See Listing <span class="InternalRef"><a href="#PC18">10-17</a></span>.<div class="ProgramCode" id="PC18"><div class="LineGroup"><div class="FixedLine">(base) binildass-MacBook-Pro:mongodata binil$ minikube ssh</div><div class="FixedLine">                         _             _</div><div class="FixedLine">            _         _ ( )           ( )</div><div class="FixedLine">  ___ ___  (_)  ___  (_)| |/')  _   _ | |_      __</div><div class="FixedLine">/' _ ` _ `\| |/' _ `\| || , &lt;  ( ) ( )| '_`\  /'__`\</div><div class="FixedLine">| ( ) ( ) || || ( ) || || |\`\ | (_) || |_) )(  ___/</div><div class="FixedLine">(_) (_) (_)(_)(_) (_)(_)(_) (_)`\___/'(_,__/'`\____)</div></div><div class="LineGroup"><div class="FixedLine">$ pwd</div><div class="FixedLine">/home/docker</div><div class="FixedLine">$ cd /home/docker</div><div class="FixedLine">$ mkdir -p binil/mongodata</div><div class="FixedLine">$ ls</div><div class="FixedLine">binil</div><div class="FixedLine">$ cd binil/mongodata/</div><div class="FixedLine">$ ls</div><div class="FixedLine">$ pwd</div><div class="FixedLine">/home/docker/binil/mongodata</div><div class="FixedLine">$ ls</div><div class="FixedLine">$</div></div><div class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Listing 10-17</span><p class="SimplePara">Creating a Local Folder Acting as Volume Mount for Mongo Data</p></div></div></div></div>

          <div class="Para" id="Par103">The simple script called <span id="ITerm76"><span class="EmphasisFontCategoryNonProportional ">makeandrun.sh</span></span> contains a single command to build and run the complete application with all the defined deployments, and it is shown in Listing <span class="InternalRef"><a href="#PC19">10-18</a></span>.<div class="ProgramCode" id="PC19"><div class="LineGroup"><div class="FixedLine">mvn -Dmaven.test.skip=true clean package</div><div class="FixedLine">docker build  --build-arg JAR_FILE=02-ProductWeb/target/*.jar -t ecom/product-web .</div><div class="FixedLine">docker build  --build-arg JAR_FILE=01-ProductServer/target/*.jar -t ecom/product-server .</div><div class="FixedLine"># docker network create ecom-network</div><div class="FixedLine"># docker pull mongo:4.2.24</div><div class="FixedLine">kubectl create -f mongo-volume.yml</div><div class="FixedLine">kubectl create -f mongo-volume-claim.yml</div><div class="FixedLine">kubectl create -f mongo-deployment.yml</div><div class="FixedLine">kubectl create -f mongo-service.yml</div><div class="FixedLine">kubectl create -f product-server-deployment.yml</div><div class="FixedLine">kubectl create -f product-server-service.yml</div><div class="FixedLine">kubectl create -f product-web-deployment.yml</div><div class="FixedLine">kubectl create -f product-web-service.yml</div><div class="FixedLine">minikube service product-web --url</div><div class="FixedLine">sleep 3</div><div class="FixedLine">kubectl get pods</div><div class="FixedLine">kubectl get services</div></div><div class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Listing 10-18</span><p class="SimplePara">The Script to Build and Run Microservices in Kubernetes (ch10\ch10-01\makeandrun.sh)</p></div></div></div></div>

          <div class="Para" id="Par104">In Appendix E, you might have noticed that I used this command from Listing E-22:<div class="ProgramCode" id="PC20"><div class="LineGroup"><div class="FixedLine">kubectl apply -f https://raw.githubusercontent.com/scriptcamp/minikube/main/nginx.yaml</div></div></div></div>

          <p class="Para" id="Par105">This is <span id="ITerm77">declarative management</span>, whereby you specify the required outcome, not the individual steps needed to achieve that outcome. This command applies a configuration to a resource by filename or stdin. The resource name must be specified. JSON and YAML formats are accepted.</p>

          <p class="Para" id="Par106">However, Listing <span class="InternalRef"><a href="#PC19">10-18</a></span> uses <span id="ITerm78"><span class="EmphasisFontCategoryNonProportional ">kubectl create</span></span>. This is an imperative way of specification, meaning that you give a series of instructions or steps to reach the goal. You specify what and how you should reach the goal. The <span class="EmphasisFontCategoryNonProportional ">kubectl create</span> command also creates a resource from a file or from stdin. JSON and YAML formats are accepted.</p>

          <div class="Para" id="Par107">You can now execute the script shown in Listing <span class="InternalRef"><a href="#PC21">10-19</a></span>.<div class="ProgramCode" id="PC21"><div class="LineGroup"><div class="FixedLine">(base) binildass-MacBook-Pro:ch10-01 binil$ pwd</div><div class="FixedLine">/Users/binil/binil/code/mac/mybooks/docker-04/Code/ch10/ch10-01</div><div class="FixedLine">(base) binildass-MacBook-Pro:ch10-01 binil$ eval $(minikube docker-env)</div><div class="FixedLine">(base) binildass-MacBook-Pro:ch10-01 binil$ sh makeandrun.sh</div><div class="FixedLine">[INFO] Scanning for projects...</div><div class="FixedLine">[INFO] --------------------------------------------------------</div><div class="FixedLine">[INFO] Reactor Build Order:</div><div class="FixedLine">[INFO]</div><div class="FixedLine">[INFO] Ecom-Product-Server-Microservice    [jar]</div><div class="FixedLine">[INFO] Ecom-Product-Web-Microservice       [jar]</div><div class="FixedLine">[INFO] Ecom                                [pom]</div><div class="FixedLine">[INFO]</div><div class="FixedLine">...</div><div class="FixedLine">[INFO]</div><div class="FixedLine">[INFO] Ecom-Product-Server-Microservice .. SUCCESS [  3.687 s]</div><div class="FixedLine">[INFO] Ecom-Product-Web-Microservice ..... SUCCESS [  0.842 s]</div><div class="FixedLine">[INFO] Ecom .............................. SUCCESS [  0.043 s]</div><div class="FixedLine">[INFO] -------------------------------------------------------</div><div class="FixedLine">[INFO] BUILD SUCCESS</div><div class="FixedLine">[INFO] -------------------------------------------------------</div><div class="FixedLine">[INFO] Total time:  4.836 s</div><div class="FixedLine">[INFO] Finished at: 2023-05-25T19:18:03+05:30</div><div class="FixedLine">[INFO] -------------------------------------------------------</div><div class="FixedLine">...</div><div class="FixedLine">persistentvolume/mongo-data-db created</div><div class="FixedLine">persistentvolumeclaim/mongo-data-db created</div><div class="FixedLine">statefulset.apps/mongo-cluster created</div><div class="FixedLine">service/mongo created</div><div class="FixedLine">service/mongo-nodeport created</div><div class="FixedLine">deployment.apps/product-server created</div><div class="FixedLine">service/product-server-nodeport created</div><div class="FixedLine">deployment.apps/product-web created</div><div class="FixedLine">service/product-web created</div><div class="FixedLine">http://192.168.64.6:30503</div><div class="FixedLine">...</div><div class="FixedLine">(base) binildass-MacBook-Pro:ch10-01 binil$</div></div><div class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Listing 10-19</span><p class="SimplePara">Executing the Script to Build and Run Microservice Pods in Kubernetes</p></div></div></div></div>

          <div class="Para" id="Par108">Once the pods are running, you can inspect the data folder created in Listing <span class="InternalRef"><a href="#PC22">10-20</a></span> and see that it has been initialized. This is because you are initializing a few rows of data in MongoDB using the <span class="EmphasisFontCategoryNonProportional ">InitializationComponent</span> class in the <span id="ITerm79">Product Server microservice</span>.<div class="ProgramCode" id="PC22"><div class="LineGroup"><div class="FixedLine">(base) binildass-MacBook-Pro:~ binil$ minikube ssh</div><div class="FixedLine">                         _             _</div><div class="FixedLine">            _         _ ( )           ( )</div><div class="FixedLine">  ___ ___  (_)  ___  (_)| |/')  _   _ | |_      __</div><div class="FixedLine">/' _ ` _ `\| |/' _ `\| || , &lt;  ( ) ( )| '_`\  /'__`\</div><div class="FixedLine">| ( ) ( ) || || ( ) || || |\`\ | (_) || |_) )(  ___/</div><div class="FixedLine">(_) (_) (_)(_)(_) (_)(_)(_) (_)`\___/'(_,__/'`\____)</div></div><div class="LineGroup"><div class="FixedLine">$ pwd</div><div class="FixedLine">/home/docker</div><div class="FixedLine">$ cd /home/docker/binil/mongodata</div><div class="FixedLine">$ ls</div><div class="FixedLine">WiredTiger                           diagnostic.data</div><div class="FixedLine">WiredTiger.lock                      index-1-840414156336134639.wt</div><div class="FixedLine">WiredTiger.turtle                    index-11-840414156336134639.wt</div><div class="FixedLine">WiredTiger.wt                        index-3-840414156336134639.wt</div><div class="FixedLine">WiredTigerLAS.wt                     index-5-840414156336134639.wt</div><div class="FixedLine">_mdb_catalog.wt                      index-6-840414156336134639.wt</div><div class="FixedLine">collection-0-840414156336134639.wt   index-9-840414156336134639.wt</div><div class="FixedLine">collection-10-840414156336134639.wt  journal</div><div class="FixedLine">collection-2-840414156336134639.wt   mongod.lock</div><div class="FixedLine">collection-4-840414156336134639.wt   sizeStorer.wt</div><div class="FixedLine">collection-8-840414156336134639.wt   storage.bson</div><div class="FixedLine">$</div></div><div class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Listing 10-20</span><p class="SimplePara">Inspecing the Local Folder Acting as Volume Mount for Mongo Data</p></div></div></div></div>

          <div class="Para" id="Par109">Once all the pods have been created, how do you know if it’s running? You can list the pods to see their status, as shown in Listing <span class="InternalRef"><a href="#PC23">10-21</a></span>.<div class="ProgramCode" id="PC23"><div class="LineGroup"><div class="FixedLine">(base) binildass-MacBook-Pro:~ binil$ kubectl get pods</div><div class="FixedLine">NAME                            READY STATUS    RESTARTS AGE</div><div class="FixedLine">mongo-cluster-0                 1/1   Running   0        3m53s</div><div class="FixedLine">product-server-6fb88b6849-q2pfx 1/1   Running   0        3m52s</div><div class="FixedLine">product-web-5dfc886d6d-8cl7t    1/1   Running   0        3m52s</div><div class="FixedLine">(base) binildass-MacBook-Pro:~ binil$</div></div><div class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Listing 10-21</span><p class="SimplePara">Listing the Status of the <span id="ITerm80">Kubernetes Pods</span></p></div></div></div></div>

          <div class="Para" id="Par110">The <span class="EmphasisFontCategoryNonProportional ">kubectl exec</span> command allows you to remotely run arbitrary commands inside an existing container of a pod. This will help when you want to examine the contents, state, and/or environment of a container. You can inspect the environment variables of the <span id="ITerm81">Product Web pod</span> in Listing <span class="InternalRef"><a href="#PC24">10-22</a></span> by referencing the pod name from Listing <span class="InternalRef"><a href="#PC23">10-21</a></span>.<div class="ProgramCode" id="PC24"><div class="LineGroup"><div class="FixedLine">(base) binildass-MacBook-Pro:~ binil$ kubectl exec product-web-5dfc886d6d-8cl7t env</div><div class="FixedLine">...</div><div class="FixedLine">acme.PRODUCT_SERVICE_URL=http://product-server:8081/products</div></div><div class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Listing 10-22</span><p class="SimplePara">Listing the Environment Variables for Product Web Microservice</p></div></div></div></div>

          <p class="Para" id="Par111">The command in Listing <span class="InternalRef"><a href="#PC24">10-22</a></span> will spit out all the environment variables that you configured in Listing <span class="InternalRef"><a href="#PC7">10-6</a></span>.</p>

          <div class="Para" id="Par112">Next, list the Kubernetes services, as shown in Listing <span class="InternalRef"><a href="#PC25">10-23</a></span>.<div class="ProgramCode" id="PC25"><div class="LineGroup"><div class="FixedLine">(base) binildass-MacBook-Pro:~ binil$ kubectl get svc</div><div class="FixedLine">NAME              TYPE         CLUSTER-IP     PORT(S)</div><div class="FixedLine">kubernetes        ClusterIP    10.96.0.1      443/TCP</div><div class="FixedLine">mongo             ClusterIP    10.98.30.13    27017/TCP</div><div class="FixedLine">mongo-nodeport    NodePort     10.110.211.153 27017:30001/TCP</div><div class="FixedLine">product-server    ClusterIP    10.102.46.205  8081/TCP</div><div class="FixedLine">product-server-np NodePort     10.109.197.184 8081:30002/TCP</div><div class="FixedLine">product-web       LoadBalancer 10.98.43.63    8080:30503/TCP</div><div class="FixedLine">(base) binildass-MacBook-Pro:~ binil$</div></div><div class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Listing 10-23</span><p class="SimplePara">Listing the <span id="ITerm82">Kubernetes Services</span></p></div></div></div></div>

          <div class="FormalPara FormalParaRenderingStyle1 ParaTypeImportant" id="FPar2">

            <div class="Heading">Note</div>

            <p class="Para FirstParaInFormalPara" id="Par113">I have abbreviated <span class="EmphasisFontCategoryNonProportional ">product-server-nodeport</span> to <span class="EmphasisFontCategoryNonProportional ">product-server-np</span> in Listing <span class="InternalRef"><a href="#PC25">10-23</a></span> for formatting convenience.</p>

          </div>

          <div class="Para" id="Par114">Listing <span class="InternalRef"><a href="#PC26">10-24</a></span> examines one of the services from Listing <span class="InternalRef"><a href="#PC25">10-23</a></span> in more detail.<div class="ProgramCode" id="PC26"><div class="LineGroup"><div class="FixedLine">(base) binildass-MacBook-Pro:~ binil$ kubectl describe svc product-web</div><div class="FixedLine">Name:                     product-web</div><div class="FixedLine">Namespace:                default</div><div class="FixedLine">Labels:                   &lt;none&gt;</div><div class="FixedLine">Annotations:              &lt;none&gt;</div><div class="FixedLine">Selector:                 app=product-web</div><div class="FixedLine">Type:                     LoadBalancer</div><div class="FixedLine">IP Family Policy:         SingleStack</div><div class="FixedLine">IP Families:              IPv4</div><div class="FixedLine">IP:                       10.98.43.63</div><div class="FixedLine">IPs:                      10.98.43.63</div><div class="FixedLine">Port:                     &lt;unset&gt;  8080/TCP</div><div class="FixedLine">TargetPort:               8080/TCP</div><div class="FixedLine">NodePort:                 &lt;unset&gt;  30503/TCP</div><div class="FixedLine">Endpoints:                10.244.1.104:8080</div><div class="FixedLine">Session Affinity:         None</div><div class="FixedLine">External Traffic Policy:  Cluster</div><div class="FixedLine">Events:                   &lt;none&gt;</div><div class="FixedLine">(base) binildass-MacBook-Pro:~ binil$</div></div><div class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Listing 10-24</span><p class="SimplePara">Describing the <span id="ITerm83">Kubernetes Service</span></p></div></div></div></div>

          <div class="Para" id="Par115">As you can see, services use an <span class="EmphasisFontCategoryNonProportional ">Endpoints</span> resource to link to a pod. An <span class="EmphasisFontCategoryNonProportional ">Endpoints</span> is a comma-separated list of IP addresses and ports exposing a service. The <span class="EmphasisFontCategoryNonProportional ">Endpoints</span> resource is like any other Kubernetes resource, so you can display its basic info with the <span class="EmphasisFontCategoryNonProportional ">kubectl</span> command, as shown in Listing <span class="InternalRef"><a href="#PC27">10-25</a></span>.<div class="ProgramCode" id="PC27"><div class="LineGroup"><div class="FixedLine">(base) binildass-MacBook-Pro:~ binil$ kubectl get endpoints product-web</div><div class="FixedLine">NAME          ENDPOINTS           AGE</div><div class="FixedLine">product-web   10.244.1.104:8080   13m</div><div class="FixedLine">(base) binildass-MacBook-Pro:~ binil$</div></div><div class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Listing 10-25</span><p class="SimplePara">Describing the <span id="ITerm84">Kubernetes Service</span> Endpoint</p></div></div></div></div>

          <div class="Para" id="Par116">Before you attempt to test these services, it will help you to keep watching the terminal logs for the Product Server and <span id="ITerm85">Product Web microservices</span>. You can view the logs with the help of the pod name from Listing <span class="InternalRef"><a href="#PC23">10-21</a></span>, as shown in Listings <span class="InternalRef"><a href="#PC28">10-26</a></span> and <span class="InternalRef"><a href="#PC29">10-27</a></span>.<div class="ProgramCode" id="PC28"><div class="LineGroup"><div class="FixedLine">(base) binildass-MacBook-Pro:~ binil$ kubectl --tail 15 logs -f product-server-6fb88b6849-q2pfx</div><div class="FixedLine"> /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \</div><div class="FixedLine">( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \</div><div class="FixedLine"> \\/  ___)| |_)| | | | | || (_| |  ) ) ) )</div><div class="FixedLine">  '  |____| .__|_| |_|_| |_\__, | / / / /</div><div class="FixedLine"> =========|_|==============|___/=/_/_/_/</div><div class="FixedLine"> :: Spring Boot ::                (v3.2.0)</div></div><div class="LineGroup"><div class="FixedLine">...</div><div class="FixedLine">2023-05-25 13:48:21 INFO  InitializationComponent.init:47 - Start...</div><div class="FixedLine">2023-05-25 13:48:21 DEBUG InitializationComponent.init:51 - Deleting all existing data...</div><div class="FixedLine">2023-05-25 13:48:22 DEBUG InitializationComponent.init:56 - Creating initial data...</div><div class="FixedLine">2023-05-25 13:48:22 INFO  InitializationComponent.init:105 - End</div><div class="FixedLine">2023-05-25 13:48:23 INFO  StartupInfoLogger.logStarted:57 - Started EcomProductMicroservice...</div><div class="FixedLine">...</div></div><div class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Listing 10-26</span><p class="SimplePara">Viewing the Product Server Microservice Terminal Logs</p></div></div></div><div class="ProgramCode" id="PC29"><div class="LineGroup"><div class="FixedLine">(base) binildass-MacBook-Pro:~ binil$ kubectl --tail 15 logs -f product-web-5dfc886d6d-8cl7t</div><div class="FixedLine">  .   ____          _            __ _ _</div><div class="FixedLine"> /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \</div><div class="FixedLine">( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \</div><div class="FixedLine"> \\/  ___)| |_)| | | | | || (_| |  ) ) ) )</div><div class="FixedLine">  '  |____| .__|_| |_|_| |_\__, | / / / /</div><div class="FixedLine"> =========|_|==============|___/=/_/_/_/</div><div class="FixedLine"> :: Spring Boot ::                (v3.2.0)</div></div><div class="LineGroup"><div class="FixedLine">...</div><div class="FixedLine">2023-05-25 13:48:20 INFO  InitializationComponent.init:37 - Start</div><div class="FixedLine">2023-05-25 13:48:20 DEBUG InitializationComponent.init:39 - Doing Nothing...</div><div class="FixedLine">2023-05-25 13:48:20 INFO  InitializationComponent.init:41 - End</div><div class="FixedLine">2023-05-25 13:48:21 INFO  StartupInfoLogger.logStarted:57 - Started EcomProductMicroservice...</div><div class="FixedLine">...</div></div><div class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Listing 10-27</span><p class="SimplePara">Viewing the Product Web Microservice Terminal Logs</p></div></div></div></div>

          <p class="Para" id="Par117">You are now ready to test the microservices.</p>

        </section>

        <section class="Section2 RenderAsSection2" id="Sec29">

          <h3 class="Heading">Testing the Microservice Pods</h3>

          <div class="Para" id="Par118">Once all the three pods are up and running, you can access the Product Web microservice. For that, as mentioned in Appendix E, you must get the Minikube IP first. See Listing <span class="InternalRef"><a href="#PC30">10-28</a></span>.<div class="ProgramCode" id="PC30"><div class="LineGroup"><div class="FixedLine">(base) binildass-MacBook-Pro:ch07-02 binil$ minikube ip</div><div class="FixedLine">192.168.64.5</div><div class="FixedLine">(base) binildass-MacBook-Pro:ch07-02 binil$</div></div><div class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Listing 10-28</span><p class="SimplePara">Finding Minikube IP</p></div></div></div></div>

          <p class="Para" id="Par119">You can now access the Product Web microservice using a browser with the URL formed with the Minikube IP.</p>

          <p class="Para ParaOneEmphasisChild" id="Par120"><span class="EmphasisFontCategoryNonProportional ">http://192.168.64.5:8080/product.html</span></p>

          <p class="Para" id="Par121">Refer to the section titled “Test the Microservice Using UI” in Chapter <span class="ExternalRef"><a href="Capítulo-03.html"><span class="RefSource">1</span></a></span> to test the Product Web microservice container.</p>

          <p class="Para" id="Par122">While you test the microservices, keep watching the log windows in Listings <span class="InternalRef"><a href="#PC28">10-26</a></span> and <span class="InternalRef"><a href="#PC29">10-27</a></span>.</p>

        </section>

        <section class="Section2 RenderAsSection2" id="Sec30">

          <h3 class="Heading">Accessing Kubernetes Deployments</h3>

          <div class="Para" id="Par123">Let’s continue the testing, with respect to the information related to the Kubernetes services in Listing <span class="InternalRef"><a href="#PC25">10-23</a></span>. You will first <span class="EmphasisFontCategoryNonProportional ">cURL</span> from a terminal in the host machine to the URL that you tested in the previous section. See Listing <span class="InternalRef"><a href="#PC31">10-29</a></span>.<div class="ProgramCode" id="PC31"><div class="LineGroup"><div class="FixedLine">(base) binildass-MacBook-Pro:~ binil$ curl http://192.168.64.6:30503/productsweb</div><div class="FixedLine">[{"productId":"646ef0a55a32df351bf88d09","name":"Kamsung ...</div><div class="FixedLine">(base) binildass-MacBook-Pro:~ binil$</div></div><div class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Listing 10-29</span><p class="SimplePara">cURL with Minikube IP Based Address</p></div></div></div></div>

          <p class="Para" id="Par124">You will be able to access the Product Web microservice and retrieve information.</p>

          <div class="Para" id="Par125">Now try with the URL formed out of the Cluster IP, as shown in Listing <span class="InternalRef"><a href="#PC32">10-30</a></span>.<div class="ProgramCode" id="PC32"><div class="LineGroup"><div class="FixedLine">(base) binildass-MacBook-Pro:~ binil$ curl http://10.98.43.63:30503/productsweb</div><div class="FixedLine">curl: (7) Failed to connect to 10.109.140.135 port 30012: Connection refused</div><div class="FixedLine">(base) binildass-MacBook-Pro:~ binil$ curl http://10.98.43.63:8080/productsweb</div><div class="FixedLine">curl: (7) Failed to connect to 10.109.140.135 port 30012: Connection refused</div><div class="FixedLine">(base) binildass-MacBook-Pro:~ binil$</div></div><div class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Listing 10-30</span><p class="SimplePara">Accessing Product Web Using cURL with Cluster IP Based URL from Host</p></div></div></div></div>

          <p class="Para" id="Par126">Cluster IP provides access only inside the Kubernetes Cluster. Other apps inside your cluster can access, but there is no external access to the service, so the <span class="EmphasisFontCategoryNonProportional ">cURL</span> command failed.</p>

          <div class="Para" id="Par127">Now try to access the service from within the Minikube host, as shown in Listing <span class="InternalRef"><a href="#PC33">10-31</a></span>.<div class="ProgramCode" id="PC33"><div class="LineGroup"><div class="FixedLine">(base) binildass-MacBook-Pro:~ binil$ minikube ssh</div><div class="FixedLine">                         _             _</div><div class="FixedLine">            _         _ ( )           ( )</div><div class="FixedLine">  ___ ___  (_)  ___  (_)| |/')  _   _ | |_      __</div><div class="FixedLine">/' _ ` _ `\| |/' _ `\| || , &lt;  ( ) ( )| '_`\  /'__`\</div><div class="FixedLine">| ( ) ( ) || || ( ) || || |\`\ | (_) || |_) )(  ___/</div><div class="FixedLine">(_) (_) (_)(_)(_) (_)(_)(_) (_)`\___/'(_,__/'`\____)</div></div><div class="LineGroup"><div class="FixedLine">$ curl http:// 10.98.43.63:30503/productsweb</div><div class="FixedLine">curl: (7) Failed to connect to 10.109.140.135 port 30012 after 10 ms: Connection refused</div><div class="FixedLine">$ curl http:// 10.98.43.63:8080/productsweb</div><div class="FixedLine">[{"productId":"646ef0a55a32df351bf88d09","name":"Kamsung ...</div></div><div class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Listing 10-31</span><p class="SimplePara">Accessing Product Web Using cURL with Cluster IP Based URL from Inside Minikube</p></div></div></div></div>

          <p class="Para" id="Par128">From within the Minikube host, the command succeeded because Cluster IP provides access to other apps from inside the Kubernetes Cluster.</p>

          <div class="Para" id="Par129">Now try to access the Product Server microservice. You already provided a <span class="EmphasisFontCategoryNonProportional ">NodePort</span> type for the service. You should therefore be able to access it from outside the Kubernetes cluster—that is, from the host machine. See Listing <span class="InternalRef"><a href="#PC34">10-32</a></span>.<div class="ProgramCode" id="PC34"><div class="LineGroup"><div class="FixedLine">(base) binildass-MacBook-Pro:~ binil$ curl http://192.168.64.6:30002/products</div><div class="FixedLine">[{"productId":"646ef0a55a32df351bf88d09","name":"Kamsung ...</div><div class="FixedLine">binildass-MacBook-Pro:~ binil$</div></div><div class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Listing 10-32</span><p class="SimplePara">Accessing Product Server Using cURL with Node Port IP Based URL from Host</p></div></div></div></div>

          <p class="Para" id="Par130">You can access the service since the cluster node opens a port on the node itself (hence the name <span class="EmphasisFontCategoryNonProportional ">NodePort</span>) and redirects traffic received on that port to the respective service.</p>

          <div class="Para" id="Par131">You may delete a pod if you want. By deleting a pod, you’re instructing Kubernetes to terminate all the containers that are part of that pod. Listing <span class="InternalRef"><a href="#PC35">10-33</a></span> shows how to delete the Product Web pod.<div class="ProgramCode" id="PC35"><div class="LineGroup"><div class="FixedLine">(base) binildass-MacBook-Pro:~ binil$ kubectl delete po product-web-5dfc886d6d-8cl7t</div><div class="FixedLine">pod "product-web-5dfc886d6d-8cl7t" deleted</div><div class="FixedLine">(base) binildass-MacBook-Pro:~ binil$</div></div><div class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Listing 10-33</span><p class="SimplePara">Deleting a Kubernetes Pod</p></div></div></div></div>

          <div class="Para" id="Par132">Once the Product Web pod has been deleted, you can again list pods to see their statuses, as shown in Listing <span class="InternalRef"><a href="#PC36">10-34</a></span>.<div class="ProgramCode" id="PC36"><div class="LineGroup"><div class="FixedLine">(base) binildass-MacBook-Pro:~ binil$ kubectl get pods</div><div class="FixedLine">NAME                            READY STATUS    RESTARTS AGE</div><div class="FixedLine">mongo-cluster-0                 1/1   Running   0        28m</div><div class="FixedLine">product-server-6fb88b6849-q2pfx 1/1   Running   0        28m</div><div class="FixedLine">product-web-5dfc886d6d-c2cps    1/1   Running   0        42s</div><div class="FixedLine">(base) binildass-MacBook-Pro:~ binil$</div></div><div class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Listing 10-34</span><p class="SimplePara">Listing the Kubernetes Pods Again</p></div></div></div></div>

          <p class="Para" id="Par133">Interestingly, you can see that the Product Web pod is not deleted. Truly speaking, it has been deleted, but then was re-created, since that is what you requested to Kubernetes when you mentioned the <span class="EmphasisFontCategoryNonProportional ">replicas: 1</span> in <span class="EmphasisFontCategoryNonProportional ">product-web-deployment.yml</span> in Listing <span class="InternalRef"><a href="#PC7">10-6</a></span>. Note that pod has a new name, since it’s not a stateful set.</p>

          <div class="Para" id="Par134">Let’s now delete a stateful set and see what happens. See Listing <span class="InternalRef"><a href="#PC37">10-35</a></span>.<div class="ProgramCode" id="PC37"><div class="LineGroup"><div class="FixedLine">(base) binildass-MacBook-Pro:~ binil$ kubectl delete po mongo-cluster-0</div><div class="FixedLine">pod "mongo-cluster-0" deleted</div><div class="FixedLine">(base) binildass-MacBook-Pro:~ binil$</div></div><div class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Listing 10-35</span><p class="SimplePara">Deleting a Kubernetes Stateful Set</p></div></div></div></div>

          <div class="Para" id="Par135">Once the Stateful set has been deleted, you can list the pods again to see their statuses (see Listing <span class="InternalRef"><a href="#PC38">10-36</a></span>).<div class="ProgramCode" id="PC38"><div class="LineGroup"><div class="FixedLine">(base) binildass-MacBook-Pro:~ binil$ kubectl get pods</div><div class="FixedLine">NAME                            READY STATUS    RESTARTS AGE</div><div class="FixedLine">mongo-cluster-0                 1/1   Running   0        3s</div><div class="FixedLine">product-server-6fb88b6849-q2pfx 1/1   Running   0        29m</div><div class="FixedLine">product-web-5dfc886d6d-c2cps    1/1   Running   0        116s</div><div class="FixedLine">(base) binildass-MacBook-Pro:~ binil$</div></div><div class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Listing 10-36</span><p class="SimplePara">Listing the Kubernetes Pods One More Time</p></div></div></div></div>

          <p class="Para" id="Par136">When you delete the stateful set, it will be re-created, since that is what you requested to Kubernetes when you mentioned <span class="EmphasisFontCategoryNonProportional ">replicas: 1</span> in <span class="EmphasisFontCategoryNonProportional ">mongo-deployment.yml</span> in Listing <span class="InternalRef"><a href="#PC11">10-10</a></span>. The pod has been given the same name as before, since it’s a stateful set.</p>

          <div class="Para" id="Par137">From an ordinary command window in your host machine, you can experiment with running commands in your Product Web container. See Listing <span class="InternalRef"><a href="#PC39">10-37</a></span>.<div class="ProgramCode" id="PC39"><div class="LineGroup"><div class="FixedLine">(base) binildass-MacBook-Pro:ch10-01 binil$ kubectl exec -it product-web-5dfc886d6d-c2cps -- ps</div><div class="FixedLine">PID   USER     TIME  COMMAND</div><div class="FixedLine">    1 root      0:17 java -jar /ecom.jar</div><div class="FixedLine">  125 root      0:00 ps</div><div class="FixedLine">(base) binildass-MacBook-Pro:ch10-01 binil$ kubectl exec -it product-web-5dfc886d6d-c2cps -- ls</div><div class="FixedLine">bin       etc       media     proc      sbin      tmp</div><div class="FixedLine">dev       home      mnt       root      srv       usr</div><div class="FixedLine">ecom.jar  lib       opt       run       sys       var</div><div class="FixedLine">(base) binildass-MacBook-Pro:ch10-01 binil$</div></div><div class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Listing 10-37</span><p class="SimplePara">Running Commands from within the <span id="ITerm86">Kubernetes Container</span></p></div></div></div></div>

          <div class="Para" id="Par138">You can even use the Bourne Shell (or <span class="EmphasisFontCategoryNonProportional ">sh</span>) to attach your shell console (in your host machine) to the shell in the running container, whereby you can interact with it, such as listing the processes, and so on. See Listing <span class="InternalRef"><a href="#PC40">10-38</a></span>.<div class="ProgramCode" id="PC40"><div class="LineGroup"><div class="FixedLine">(base) binildass-MacBook-Pro:ch10-01 binil$ kubectl exec -it product-web-5dfc886d6d-c2cps -- sh</div><div class="FixedLine">/ # ps -e</div><div class="FixedLine">PID   USER     TIME  COMMAND</div><div class="FixedLine">    1 root      0:17 java -jar /ecom.jar</div><div class="FixedLine">  144 root      0:00 sh</div><div class="FixedLine">  151 root      0:00 ps -e</div><div class="FixedLine">/ # exit</div><div class="FixedLine">(base) binildass-MacBook-Pro:ch10-01 binil$</div></div><div class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Listing 10-38</span><p class="SimplePara">Attaching the Shell Console to a Container</p></div></div></div></div>

          <div class="Para" id="Par139">Once you complete the tests, you can stop and remove the microservice containers and clean the environment using the <span class="EmphasisFontCategoryNonProportional ">clean.sh</span> script in Listing <span class="InternalRef"><a href="#PC41">10-39</a></span>.<div class="ProgramCode" id="PC41"><div class="LineGroup"><div class="FixedLine">mvn -Dmaven.test.skip=true clean</div><div class="FixedLine">kubectl delete -f product-web-service.yml</div><div class="FixedLine">kubectl delete -f product-web-deployment.yml</div><div class="FixedLine">kubectl delete -f product-server-service.yml</div><div class="FixedLine">kubectl delete -f product-server-deployment.yml</div><div class="FixedLine">kubectl delete -f mongo-service.yml</div><div class="FixedLine">kubectl delete -f mongo-deployment.yml</div><div class="FixedLine">kubectl delete -f mongo-volume-claim.yml</div><div class="FixedLine">kubectl delete -f mongo-volume.yml</div><div class="FixedLine">docker rmi -f ecom/product-web</div><div class="FixedLine">docker rmi -f ecom/product-server</div></div><div class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Listing 10-39</span><p class="SimplePara">The Script to Bring Down <span id="ITerm87">Microservices Kubernetes</span> Pods (ch10\ch10-01\clean.sh)</p></div></div></div></div>

          <p class="Para" id="Par140">Like the <span class="EmphasisFontCategoryNonProportional ">kubectl create</span> command you saw in Listing <span class="InternalRef"><a href="#PC19">10-18</a></span>, <span class="EmphasisFontCategoryNonProportional ">kubectl delete</span> can be used to delete resources by filename, stdin, resources, and names, or by resources and label selector, which is done in Listing <span class="InternalRef"><a href="#PC41">10-39</a></span>. JSON and YAML formats are accepted.</p>

          <div class="Para" id="Par141">You can execute this script to stop and remove the microservice pods and clean the environment, as shown in Listing <span class="InternalRef"><a href="#PC42">10-40</a></span>.<div class="ProgramCode" id="PC42"><div class="LineGroup"><div class="FixedLine">(base) binildass-MacBook-Pro:ch10-01 binil$ pwd</div><div class="FixedLine">/Users/binil/binil/code/mac/mybooks/docker-04/Code/ch10/ch10-01</div><div class="FixedLine">(base) binildass-MacBook-Pro:ch10-01 binil$ eval $(minikube docker-env)</div><div class="FixedLine">(base) binildass-MacBook-Pro:ch10-01 binil$ sh clean.sh</div><div class="FixedLine">[INFO] Scanning for projects...</div><div class="FixedLine">[INFO] ----------------------------------------------------</div><div class="FixedLine">[INFO] Reactor Build Order:</div><div class="FixedLine">[INFO]</div><div class="FixedLine">[INFO] Ecom-Product-Server-Microservice      [jar]</div><div class="FixedLine">[INFO] Ecom-Product-Web-Microservice         [jar]</div><div class="FixedLine">[INFO] Ecom                                  [pom]</div><div class="FixedLine">[INFO]</div><div class="FixedLine">...</div><div class="FixedLine">[INFO]</div><div class="FixedLine">[INFO] Ecom-Product-Server-Microservice . SUCCESS [  0.108 s]</div><div class="FixedLine">[INFO] Ecom-Product-Web-Microservice .... SUCCESS [  0.008 s]</div><div class="FixedLine">[INFO] Ecom ............................. SUCCESS [  0.037 s]</div><div class="FixedLine">[INFO] ---------------------------------------------------</div><div class="FixedLine">[INFO] BUILD SUCCESS</div><div class="FixedLine">[INFO] ---------------------------------------------------</div><div class="FixedLine">[INFO] Total time:  0.366 s</div><div class="FixedLine">[INFO] Finished at: 2023-05-19T16:40:53+05:30</div><div class="FixedLine">[INFO] ---------------------------------------------------</div><div class="FixedLine"> "product-web" deleted</div><div class="FixedLine">deployment.apps "product-web" deleted</div><div class="FixedLine">service "product-server" deleted</div><div class="FixedLine">service "product-server-nodeport" deleted</div><div class="FixedLine">deployment.apps "product-server" deleted</div><div class="FixedLine">service "mongo" deleted</div><div class="FixedLine">service "mongo-nodeport" deleted</div><div class="FixedLine">statefulset.apps "mongo-cluster" deleted</div><div class="FixedLine">persistentvolumeclaim "mongo-data-db" deleted</div><div class="FixedLine">persistentvolume "mongo-data-db" deleted</div><div class="FixedLine">Untagged: ecom/product-web:latest</div><div class="FixedLine">Untagged: ecom/product-server:latest</div><div class="FixedLine">(base) binildass-MacBook-Pro:ch10-01 binil$</div></div><div class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Listing 10-40</span><p class="SimplePara">Stopping Microservice Pods and Cleaning the Environment</p></div></div></div></div>

          <p class="Para" id="Par142">This completes your first microservices example in Kubernetes.</p>

        </section>

      </section>

      <section class="Section1 RenderAsSection1" id="Sec31">

        <h2 class="Heading">Microservices and PostgreSQL in Kubernetes</h2>

        <p class="Para" id="Par143">Chapter <span class="ExternalRef"><a href="Capítulo-10.html"><span class="RefSource">8</span></a></span> showed a full-fledged microservice example interaction with a PostgreSQL database, all in Docker containers. In Chapter <span class="ExternalRef"><a href="Capítulo-11.html"><span class="RefSource">9</span></a></span>, you modified that example to be fully deployed within a container infrastructure using Docker Compose. This section now deploys the same example in Kubernetes.</p>

        <section class="Section2 RenderAsSection2" id="Sec32">

          <h3 class="Heading">Design Microservices Deployment Topology</h3>

          <div class="Para" id="Par144">The <span id="ITerm88">Product Web and Product Server</span> microservices are containerized, and the Product Server microservice will connect to a <span id="ITerm89">PostgreSQL database</span>, again deployed within a container. All these containers will now run in Kubernetes. See Figure <span class="InternalRef"><a href="#Fig12">10-12</a></span>.<figure class="Figure" id="Fig12"><div class="MediaObject" id="MO12"><img alt="" aria-describedby="d64e3282" src="../images/619782_1_En_10_Chapter/Imagem-117.jpg" style="width:35.15em"/><div class="TextObject" id="d64e3282"><p class="Para" id="Par205">A diagram illustrates how a user interacts with a browser, which sends requests to a product web microservice. It comprises multiple product-web pods that communicate with a product server microservice, which utilizes a post g r e S Q L database, deployed on a kubernetes cluster by minikube and docker.</p></div></div><figcaption class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Figure 10-12</span><p class="SimplePara">Kubernetes based deployment topology for microservices</p></div></figcaption></figure></div>

          <p class="Para" id="Par145">Here, the Product Web and Product Server containers provide business services, whereas the <span id="ITerm90">PostgreSQL</span> container provides application services for persisting state.</p>

        </section>

        <section class="Section2 RenderAsSection2" id="Sec33">

          <h3 class="Heading">Understanding the Source Code</h3>

          <p class="Para" id="Par146">The <span id="ITerm91">source code</span> for this book is available on GitHub via the book’s product page, located at <span class="ExternalRef"><a href="http://www.apress.com/9798868805547"><span class="RefSource"><span class="EmphasisFontCategoryNonProportional ">www.apress.com/9798868805547</span></span></a></span>. The source code for the example is organized inside the <span class="EmphasisFontCategoryNonProportional ">ch10\ch10-02</span> folder. Much of the source code in this example is similar to <span class="EmphasisFontCategoryNonProportional ">ch03\ch03-01</span>, which was explained in detail in Chapter <span class="ExternalRef"><a href="Capítulo-05.html"><span class="RefSource">3</span></a></span>, in the section titled “Microservices Using PostgreSQL and RestTemplate.” You also saw Docker-based deployment of the topology in Figure <span class="ExternalRef"><a href="Capítulo-10.html#Fig7"><span class="RefSource">8-7</span></a></span>, in the section titled “Microservice and PostgreSQL in Container” in Chapter <span class="ExternalRef"><a href="Capítulo-10.html"><span class="RefSource">8</span></a></span> and subsequently in the Docker Compose-based deployment of the topology in Figure <span class="ExternalRef"><a href="Capítulo-11.html#Fig1"><span class="RefSource">9-1</span></a></span>, in the section titled “Composing Microservice with PostgreSQL Containers” in Chapter <span class="ExternalRef"><a href="Capítulo-11.html"><span class="RefSource">9</span></a></span>. That means you can straight away get into the Kubernetes-specific aspects.</p>

          <div class="Para" id="Par147">A summarized representation of the source code organization for the example inside the <span class="EmphasisFontCategoryNonProportional ">ch10-02</span> folder is shown in Listing <span class="InternalRef"><a href="#PC43">10-41</a></span>.<div class="ProgramCode" id="PC43"><div class="LineGroup"><div class="FixedLine">./ch10-02/</div><div class="FixedLine">├── 01-ProductServer</div><div class="FixedLine">│   ├── pom.xml</div><div class="FixedLine">│   └── src</div><div class="FixedLine">│       └── ...</div><div class="FixedLine">├── 02-ProductWeb</div><div class="FixedLine">│   ├── pom.xml</div><div class="FixedLine">│   └── src</div><div class="FixedLine">│       └── ...</div><div class="FixedLine">├── Dockerfile</div><div class="FixedLine">├── README.txt</div><div class="FixedLine">├── clean.sh</div><div class="FixedLine">├── makeandrun.sh</div><div class="FixedLine">├── pom.xml</div><div class="FixedLine">├── postgres-config.yml</div><div class="FixedLine">├── postgres-deployment.yml</div><div class="FixedLine">├── postgres-pvc.yml</div><div class="FixedLine">├── postgres-svc.yml</div><div class="FixedLine">├── product-server-deployment.yml</div><div class="FixedLine">├── product-server-service.yml</div><div class="FixedLine">├── product-web-deployment.yml</div><div class="FixedLine">└── product-web-service.yml</div></div><div class="LineGroup"><div class="FixedLine">32 directories, 43 files</div><div class="FixedLine">(base) binildass-MacBook-Pro:ch10 binil$</div></div><div class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Listing 10-41</span><p class="SimplePara">Example 10-02 <span id="ITerm92">Source Code</span> Organization</p></div></div></div></div>

          <p class="Para" id="Par148">The <span id="ITerm93">Dockerfile</span> is similar to the one in Listing 7-35 of Chapter <span class="ExternalRef"><a href="Capítulo-09.html"><span class="RefSource">7</span></a></span>, so I do not repeat the explanation here. There are a set of <span class="EmphasisFontCategoryNonProportional ">.yml</span> files, many of them you have already seen in the previous example in this chapter. There are two new descriptors required for the PostgreSQL database, which you will learn about now.</p>

          <div class="Para" id="Par149">The change from <span id="ITerm94">MongoDB</span> in the previous example to the PostgreSQL DB in this example starts from the Product Server microservice deployment descriptor. See Listing <span class="InternalRef"><a href="#PC44">10-42</a></span>.<div class="ProgramCode" id="PC44"><div class="LineGroup"><div class="FixedLine">apiVersion: apps/v1</div><div class="FixedLine">kind: Deployment</div><div class="FixedLine">metadata:</div><div class="FixedLine">  name: product-server</div><div class="FixedLine">  ...</div><div class="FixedLine">spec:</div><div class="FixedLine">  ...</div><div class="FixedLine">  template:</div><div class="FixedLine">    ...</div><div class="FixedLine">    spec:</div><div class="FixedLine">      containers:</div><div class="FixedLine">      - name: product-server</div><div class="FixedLine">        ...</div><div class="FixedLine">        envFrom:</div><div class="FixedLine">          - configMapRef:</div><div class="FixedLine">              name: postgres-config</div><div class="FixedLine">        env:</div><div class="FixedLine">          - name: DB_SERVER</div><div class="FixedLine">            value: postgres</div></div><div class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Listing 10-42</span><p class="SimplePara">The Pod Definition YAML File for Product Server (ch10\ch10-02\product-server-deployment.yml)</p></div></div></div></div>

          <p class="Para" id="Par150">As mentioned earlier, much of the configurations in Listing <span class="InternalRef"><a href="#PC44">10-42</a></span> we have already seen in the just previous example in this chapter, so it’s not reproduced here or explained again.</p>

          <div class="Para" id="Par151">When you have more than just a few entries as environment variables, instead of creating each environment variable from each entry individually, <span id="ITerm95">Kubernetes</span> provides a way to expose all entries of a <span id="ITerm96"><span class="EmphasisFontCategoryNonProportional ">ConfigMap</span></span> as environment variables, as shown in Listing <span class="InternalRef"><a href="#PC45">10-43</a></span>. You can expose them as environment variables by using the <span class="EmphasisFontCategoryNonProportional ">envFrom</span> attribute, instead of <span class="EmphasisFontCategoryNonProportional ">env</span>. You still also use <span class="EmphasisFontCategoryNonProportional ">env</span> the way you did in previous examples—to refer to the PostgreSQL DB address. Listing <span class="InternalRef"><a href="#PC45">10-43</a></span> shows the entries of this <span class="EmphasisFontCategoryNonProportional ">ConfigMap</span>.<div class="ProgramCode" id="PC45"><div class="LineGroup"><div class="FixedLine">apiVersion: v1</div><div class="FixedLine">kind: ConfigMap</div><div class="FixedLine">metadata:</div><div class="FixedLine">  name: postgres-config</div><div class="FixedLine">  labels:</div><div class="FixedLine">    group: db</div><div class="FixedLine">data:</div><div class="FixedLine">  POSTGRES_DB: productdb</div><div class="FixedLine">  POSTGRES_USER: postgres</div><div class="FixedLine">  POSTGRES_PASSWORD: postgre</div></div><div class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Listing 10-43</span><p class="SimplePara">The ConfigMap YAML Referenced by the Product Server (ch10\ch10-02\postgres-config.yml)</p></div></div></div></div>

          <p class="Para" id="Par152">These entries are for the PostgreSQL server configuration. They are self-explanatory.</p>

          <div class="Para" id="Par153">The PostgreSQL database referred to in Listing <span class="InternalRef"><a href="#PC44">10-42</a></span> is also new, and Listing <span class="InternalRef"><a href="#PC46">10-44</a></span> shows its descriptors.<div class="ProgramCode" id="PC46"><div class="LineGroup"><div class="FixedLine">apiVersion: apps/v1</div><div class="FixedLine">kind: Deployment</div><div class="FixedLine">metadata:</div><div class="FixedLine">  name: postgres</div><div class="FixedLine">  labels:</div><div class="FixedLine">    app: postgres</div><div class="FixedLine">    group: db</div><div class="FixedLine">spec:</div><div class="FixedLine">  replicas: 1</div><div class="FixedLine">  selector:</div><div class="FixedLine">    matchLabels:</div><div class="FixedLine">      app: postgres</div><div class="FixedLine">  template:</div><div class="FixedLine">    metadata:</div><div class="FixedLine">      labels:</div><div class="FixedLine">        app: postgres</div><div class="FixedLine">        type: db</div><div class="FixedLine">    spec:</div><div class="FixedLine">      volumes:</div><div class="FixedLine">        - name: postgres-storage</div><div class="FixedLine">          persistentVolumeClaim:</div><div class="FixedLine">            claimName: postgres-persistent-volume-claim</div><div class="FixedLine">      containers:</div><div class="FixedLine">        - name: postgres</div><div class="FixedLine">          image: postgres:15.3-alpine3.18</div><div class="FixedLine">          ports:</div><div class="FixedLine">            - containerPort: 5432</div><div class="FixedLine">          envFrom:</div><div class="FixedLine">            - configMapRef:</div><div class="FixedLine">                name: postgres-config</div><div class="FixedLine">          volumeMounts:</div><div class="FixedLine">            - name: postgres-storage</div><div class="FixedLine">              mountPath: /var/lib/postgresql/data</div></div><div class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Listing 10-44</span><p class="SimplePara">Pod Description for the <span id="ITerm97">PostgreSQL Database</span> (ch10\ch10-02\postgres-deployment.yml)</p></div></div></div></div>

          <p class="Para" id="Par154">Note that the <span id="ITerm98">PostgreSQL pod</span> is referring to the same <span class="EmphasisFontCategoryNonProportional ">ConfigMap</span> the Product Server microservice referred to. In this manner, using the same credentials the PostgreSQL DB container has been instantiated with, the Product Server Microservice can connect to that database.</p>

          <div class="Para" id="Par155">Next, inspect the <span class="EmphasisFontCategoryNonProportional ">persistentVolumeClaim</span>, as shown in Listing <span class="InternalRef"><a href="#PC47">10-45</a></span>.<div class="ProgramCode" id="PC47"><div class="LineGroup"><div class="FixedLine">apiVersion: v1</div><div class="FixedLine">kind: PersistentVolumeClaim</div><div class="FixedLine">metadata:</div><div class="FixedLine">  name: postgres-persistent-volume-claim</div><div class="FixedLine">spec:</div><div class="FixedLine">  accessModes:</div><div class="FixedLine">    - ReadWriteOnce</div><div class="FixedLine">  resources:</div><div class="FixedLine">    requests:</div><div class="FixedLine">      storage: 4Gi</div></div><div class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Listing 10-45</span><p class="SimplePara">Description for the persistentVolumeClaim for the PostgreSQL Database (ch10\ch10-02\postgres-pvc.yml)</p></div></div></div></div>

          <div class="Para" id="Par156">The last file you will inspect is the service definition for the PostgreSQL database, as shown in Listing <span class="InternalRef"><a href="#PC48">10-46</a></span>.<div class="ProgramCode" id="PC48"><div class="LineGroup"><div class="FixedLine">apiVersion: v1</div><div class="FixedLine">kind: Service</div><div class="FixedLine">metadata:</div><div class="FixedLine">  name: postgres</div><div class="FixedLine">  labels:</div><div class="FixedLine">    group: db</div><div class="FixedLine">spec:</div><div class="FixedLine">  type: ClusterIP</div><div class="FixedLine">  selector:</div><div class="FixedLine">    app: postgres</div><div class="FixedLine">  ports:</div><div class="FixedLine">    - port: 5432</div><div class="FixedLine">      targetPort: 5432</div></div><div class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Listing 10-46</span><p class="SimplePara">Description for the <span id="ITerm99">PostgreSQL Database Service</span> (ch10\ch10-02\postgres-svc.yml)</p></div></div></div></div>

          <p class="Para" id="Par157">Only the Product Server microservice will access the PostgreSQL database from within the Kubernetes VM, so you only need a <span class="EmphasisFontCategoryNonProportional ">ClusterIP</span>.</p>

        </section>

        <section class="Section2 RenderAsSection2" id="Sec34">

          <h3 class="Heading">Run Microservices in Kubernetes</h3>

          <p class="Para" id="Par158">The <span class="EmphasisFontCategoryNonProportional ">ch10\ch10-02</span> folder contains the scripts required to build and run these examples. The first step is to start a Minikube single-node Kubernetes cluster. Refer to Appendix E for a quick reference to the Kubernetes setup and commands. Subsequently, you also need to set the <span id="ITerm100">Minikube environment</span> variables in your work terminal.</p>

          <div class="Para" id="Par159">Assuming that your single-node Kubernetes cluster Minikube is up and running, the simple script called <span class="EmphasisFontCategoryNonProportional ">makeandrun.sh</span> contains all the commands needed to build and run the complete application with all the deployment descriptors, as shown in Listing <span class="InternalRef"><a href="#PC49">10-47</a></span>.<div class="ProgramCode" id="PC49"><div class="LineGroup"><div class="FixedLine">mvn -Dmaven.test.skip=true clean package</div><div class="FixedLine">docker build  --build-arg JAR_FILE=02-ProductWeb/target/*.jar -t ecom/product-web .</div><div class="FixedLine">docker build  --build-arg JAR_FILE=01-ProductServer/target/*.jar -t ecom/product-server .</div><div class="FixedLine">kubectl create -f postgres-config.yml</div><div class="FixedLine">kubectl create -f postgres-pvc.yml</div><div class="FixedLine">kubectl create -f postgres-deployment.yml</div><div class="FixedLine">kubectl create -f postgres-svc.yml</div><div class="FixedLine">kubectl create -f product-server-deployment.yml</div><div class="FixedLine">kubectl create -f product-server-service.yml</div><div class="FixedLine">kubectl create -f product-web-deployment.yml</div><div class="FixedLine">kubectl create -f product-web-service.yml</div><div class="FixedLine">minikube service product-web --url</div><div class="FixedLine">sleep 3</div><div class="FixedLine">kubectl get pods</div><div class="FixedLine">kubectl get services</div></div><div class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Listing 10-47</span><p class="SimplePara">The Script to Build and Run Microservices in Kubernetes (ch10\ch10-02\makeandrun.sh)</p></div></div></div></div>

          <div class="Para" id="Par160">You can now execute this script, as shown in Listing <span class="InternalRef"><a href="#PC50">10-48</a></span>.<div class="ProgramCode" id="PC50"><div class="LineGroup"><div class="FixedLine">(base) binildass-MacBook-Pro:ch10-02 binil$ pwd</div><div class="FixedLine">/Users/binil/binil/code/mac/mybooks/docker-04/Code/ch10/ch10-02</div><div class="FixedLine">(base) binildass-MacBook-Pro:ch10-01 binil$ eval $(minikube docker-env)</div><div class="FixedLine">(base) binildass-MacBook-Pro:ch10-02 binil$ sh makeandrun.sh</div><div class="FixedLine">[INFO] Scanning for projects...</div><div class="FixedLine">[INFO] ------------------------------------------------------</div><div class="FixedLine">[INFO] Reactor Build Order:</div><div class="FixedLine">[INFO]</div><div class="FixedLine">[INFO] Ecom-Product-Server-Microservice                 [jar]</div><div class="FixedLine">[INFO] Ecom-Product-Web-Microservice                    [jar]</div><div class="FixedLine">[INFO] Ecom                                             [pom]</div><div class="FixedLine">[INFO]</div><div class="FixedLine">...</div><div class="FixedLine">[INFO]</div><div class="FixedLine">[INFO] Ecom-Product-Server-Microservice . SUCCESS [  3.001 s]</div><div class="FixedLine">[INFO] Ecom-Product-Web-Microservice .... SUCCESS [  0.572 s]</div><div class="FixedLine">[INFO] Ecom ............................. SUCCESS [  0.029 s]</div><div class="FixedLine">[INFO] ------------------------------------------------------</div><div class="FixedLine">[INFO] BUILD SUCCESS</div><div class="FixedLine">[INFO] ------------------------------------------------------</div><div class="FixedLine">[INFO] Total time:  3.762 s</div><div class="FixedLine">[INFO] Finished at: 2023-05-25T22:47:54+05:30</div><div class="FixedLine">[INFO] ------------------------------------------------------</div><div class="FixedLine">...</div><div class="FixedLine">configmap/postgres-config created</div><div class="FixedLine">persistentvolumeclaim/postgres-persistent-volume-claim created</div><div class="FixedLine">deployment.apps/postgres created</div><div class="FixedLine">service/postgres created</div><div class="FixedLine">deployment.apps/product-server created</div><div class="FixedLine">service/product-server created</div><div class="FixedLine">service/product-server-nodeport created</div><div class="FixedLine">deployment.apps/product-web created</div><div class="FixedLine">service/product-web created</div><div class="FixedLine">http://192.168.64.6:30263</div><div class="FixedLine">...</div><div class="FixedLine">(base) binildass-MacBook-Pro:ch10-02 binil$</div></div><div class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Listing 10-48</span><p class="SimplePara">Executing the Script to Build and Run Microservices Pods in Kubernetes</p></div></div></div></div>

          <p class="Para" id="Par161">You are now ready to test the microservices.</p>

        </section>

        <section class="Section2 RenderAsSection2" id="Sec35">

          <h3 class="Heading">Testing the Microservice Pods</h3>

          <div class="Para" id="Par162">Once the pods are up and running, you can access the Product Web microservice. However, as mentioned in Appendix E, you must get the Minikube IP first. See Listing <span class="InternalRef"><a href="#PC51">10-49</a></span>.<div class="ProgramCode" id="PC51"><div class="LineGroup"><div class="FixedLine">(base) binildass-MacBook-Pro:ch07-02 binil$ minikube ip</div><div class="FixedLine">192.168.64.6</div><div class="FixedLine">(base) binildass-MacBook-Pro:ch07-02 binil$</div></div><div class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Listing 10-49</span><p class="SimplePara">Finding <span id="ITerm101">Minikube IP</span></p></div></div></div></div>

          <p class="Para" id="Par163">You can now access the Product Web microservice using a browser with the URL formed with the Minikube IP.</p>

          <p class="Para ParaOneEmphasisChild" id="Par164"><span class="EmphasisFontCategoryNonProportional ">http://192.168.64.5:8080/product.html</span></p>

          <p class="Para" id="Par165">Refer to the section titled “Test the Microservice Using UI” in Chapter <span class="ExternalRef"><a href="Capítulo-03.html"><span class="RefSource">1</span></a></span> to test the Product Web microservice container.</p>

          <p class="Para" id="Par166">While you test the microservices, keep watching the log windows, as was described in the previous example in this chapter, in Listings <span class="InternalRef"><a href="#PC28">10-26</a></span> and <span class="InternalRef"><a href="#PC29">10-27</a></span>.</p>

          <div class="Para" id="Par167">Now you’ll look a little more into the PostgreSQL database. Listing <span class="InternalRef"><a href="#PC52">10-50</a></span> declares a persistent volume claim.<div class="ProgramCode" id="PC52"><div class="LineGroup"><div class="FixedLine">(base) binildass-MacBook-Pro:~ binil$ kubectl get persistentvolumeclaims</div><div class="FixedLine">NAME                               STATUS   VOLUME                                     CAPACITY   ACCESS MODES   STORAGECLASS   AGE</div><div class="FixedLine">postgres-persistent-volume-claim   Bound    pvc-2c90c05e-c233-44d4-8adb-5595da8edc3e   4Gi        RWO            standard       71s</div><div class="FixedLine">(base) binildass-MacBook-Pro:~ binil$</div></div><div class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Listing 10-50</span><p class="SimplePara">Describing the PVC</p></div></div></div></div>

          <p class="Para" id="Par168">Notice that the PVC has a status of <span class="EmphasisFontCategoryNonProportional ">Bound</span> and it tells you which <span class="EmphasisFontCategoryNonProportional ">VOLUME</span> they are bound to. They have a set capacity of <span class="EmphasisFontCategoryNonProportional ">4Gi</span> (this was requested in the <span class="EmphasisFontCategoryNonProportional ">yaml</span> file in Listing <span class="InternalRef"><a href="#PC47">10-45</a></span>) and they have a specified access mode of <span class="EmphasisFontCategoryNonProportional ">RWO</span> (read-write once), meaning one pod can use this volume at a time.</p>

          <p class="Para" id="Par169">Even though you didn’t set a storage class, it was set by default. This is done by an <span id="ITerm102"><span class="EmphasisFontCategoryNonProportional ">AdmissionController</span></span> that’s running in the Kubernetes cluster, intercepting your requests to the Kubernetes API server and modifying the incoming objects. If you had specified a storage class, the admission controller would not have injected this class.</p>

          <div class="Para" id="Par170">But then, who created this storage class? You can inspect the storage class in Listing <span class="InternalRef"><a href="#PC53">10-51</a></span>.<div class="ProgramCode" id="PC53"><div class="LineGroup"><div class="FixedLine">(base) binildass-MacBook-Pro:~ binil$ kubectl describe storageclass standard</div><div class="FixedLine">Name:            standard</div><div class="FixedLine">IsDefaultClass:  Yes</div><div class="FixedLine">...</div><div class="FixedLine">Provisioner:           k8s.io/minikube-hostpath</div><div class="FixedLine">Parameters:            &lt;none&gt;</div><div class="FixedLine">AllowVolumeExpansion:  &lt;unset&gt;</div><div class="FixedLine">MountOptions:          &lt;none&gt;</div><div class="FixedLine">ReclaimPolicy:         Delete</div><div class="FixedLine">VolumeBindingMode:     Immediate</div><div class="FixedLine">Events:                &lt;none&gt;</div><div class="FixedLine">(base) binildass-MacBook-Pro:~ binil$</div></div><div class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Listing 10-51</span><p class="SimplePara">Describing the <span id="ITerm103">Storage Class</span></p></div></div></div></div>

          <p class="Para" id="Par171">When you started Minikube, the <span id="ITerm104"><span class="EmphasisFontCategoryNonProportional ">StorageClass</span></span> is created for you. It’s bootstrapped for you in your Minikube installation. You can read its contents. You can modify it inside of Kubernetes, by using <span class="EmphasisFontCategoryNonProportional ">kubectl edit sc standard</span>.</p>

          <div class="Para" id="Par172">Because you have a default storage class with a provisioner, you don’t have to worry about creating a persistent volume explicitly. Instead, the provisioner takes care of creating those volumes based on the persistent volume claims. That is why a PV isn’t provisioned explicitly, unlike the last example. Listing <span class="InternalRef"><a href="#PC54">10-52</a></span> shows the PV.<div class="ProgramCode" id="PC54"><div class="LineGroup"><div class="FixedLine">(base) binildass-MacBook-Pro:~ binil$ kubectl get persistentvolumes</div><div class="FixedLine">NAME                                       CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS   CLAIM                                      STORAGECLASS   REASON   AGE</div><div class="FixedLine">pvc-2c90c05e-c233-44d4-8adb-5595da8edc3e   4Gi        RWO            Delete           Bound    default/postgres-persistent-volume-claim   standard                2m33s</div><div class="FixedLine">(base) binildass-MacBook-Pro:~ binil$</div></div><div class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Listing 10-52</span><p class="SimplePara">Listing the <span id="ITerm105">Persistent Volumes</span></p></div></div></div></div>

          <p class="Para" id="Par173">Note that the Capacity and Access Mode match the <span class="EmphasisFontCategoryNonProportional ">PersistentVolumeClaim</span>. Also note that <span class="EmphasisFontCategoryNonProportional ">PersistentVolumes</span> point to the PVC that has claimed it, just like PVCs point to the <span class="EmphasisFontCategoryNonProportional ">PersistentVolumes</span> that they have claimed.</p>

          <p class="Para" id="Par174">Before you stop the pods and services, read the next section.</p>

        </section>

      </section>

      <section class="Section1 RenderAsSection1" id="Sec36">

        <h2 class="Heading">Resiliency of Kubernetes Pods</h2>

        <p class="Para" id="Par175">In the first example in this chapter, you saw that when a pod is killed, a new pod is resurrected by default. You also saw that for a stateful set, when the pod is re-created, the name of the pod is retained.</p>

        <p class="Para" id="Par176">This demonstrates the resiliency of different kinds of pods and deployments.</p>

        <p class="Para" id="Par177">In the following sections, you’ll perform a few more experiments with the <span id="ITerm106">PostgreSQL pod</span>.</p>

        <section class="Section2 RenderAsSection2" id="Sec37">

          <h3 class="Heading">State Retention</h3>

          <div class="Para" id="Par178">First list the existing pods, as shown in Listing <span class="InternalRef"><a href="#PC55">10-53</a></span>.<div class="ProgramCode" id="PC55"><div class="LineGroup"><div class="FixedLine">(base) binildass-MacBook-Pro:~ binil$ kubectl get pods</div><div class="FixedLine">NAME                           READY STATUS  RESTARTS AGE</div><div class="FixedLine">postgres-89dbf9fd9-f5bmc       1/1   Running 0        37m</div><div class="FixedLine">product-server-85d84cf89-kxvfw 1/1   Running 0        37m</div><div class="FixedLine">product-web-69b5948fb9-brdnf   1/1   Running 0        37m</div><div class="FixedLine">(base) binildass-MacBook-Pro:~ binil$</div></div><div class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Listing 10-53</span><p class="SimplePara">Listing the <span id="ITerm107">Kubernetes Pods</span></p></div></div></div></div>

          <div class="Para" id="Par179">In Listing <span class="InternalRef"><a href="#PC56">10-54</a></span>, you can see that the PostgreSQL pod is not defined as a stateful set, but as a deployment. Keeping that in mind, you can delete the pod.<div class="ProgramCode" id="PC56"><div class="LineGroup"><div class="FixedLine">(base) binildass-MacBook-Pro:~ binil$ kubectl delete po postgres-89dbf9fd9-f5bmc</div><div class="FixedLine">pod "postgres-89dbf9fd9-f5bmc" deleted</div><div class="FixedLine">(base) binildass-MacBook-Pro:~ binil$</div></div><div class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Listing 10-54</span><p class="SimplePara">Deleting the <span id="ITerm108">PostgreSQL Pod</span></p></div></div></div></div>

          <div class="Para" id="Par180">Now list the remaining pods again, as shown in Listing <span class="InternalRef"><a href="#PC57">10-55</a></span>.<div class="ProgramCode" id="PC57"><div class="LineGroup"><div class="FixedLine">(base) binildass-MacBook-Pro:~ binil$ kubectl get pods</div><div class="FixedLine">NAME                           READY STATUS  RESTARTS AGE</div><div class="FixedLine">postgres-89dbf9fd9-4r5wk       1/1   Running 0        9s</div><div class="FixedLine">product-server-85d84cf89-kxvfw 1/1   Running 0        38m</div><div class="FixedLine">product-web-69b5948fb9-brdnf   1/1   Running 0        38m</div><div class="FixedLine">(base) binildass-MacBook-Pro:~ binil$</div></div><div class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Listing 10-55</span><p class="SimplePara">Listing the Kubernetes Pods Again</p></div></div></div></div>

          <p class="Para" id="Par181">Note that the <span id="ITerm109">PostgreSQL database</span> pod has been re-created, but with a different name. What will happen to the state of the deleted pod?</p>

          <p class="Para" id="Par182">To answer this question, test the Product Web microservice using the same URL so that the request will hit through the earlier existing Product Server and Product Web microservice pods.</p>

          <p class="Para ParaOneEmphasisChild" id="Par183"><span class="EmphasisFontCategoryNonProportional ">http://192.168.64.6:30263/product.html</span></p>

          <p class="Para" id="Par184">To your surprise, you may see that the previous state is maintained. By state, I mean, when you initialized the Product Server microservice, you inserted a few database rows, and those are retained!</p>

          <div class="Para" id="Par185">You need to explore further. To do that, check out Listing <span class="InternalRef"><a href="#PC58">10-56</a></span>, which inspects the association between pods, PVCs, and PVs.<div class="ProgramCode" id="PC58"><div class="LineGroup"><div class="FixedLine">(base) binildass-MacBook-Pro:~ binil$ kubectl get pods --all-namespaces -o=json | jq -c '.items[] | {name: .metadata.name, namespace: .metadata.namespace, claimName: .spec |  select( has ("volumes") ).volumes[] | select( has ("persistentVolumeClaim") ).persistentVolumeClaim.claimName }'</div><div class="FixedLine">{"name":"postgres-89dbf9fd9-4r5wk","namespace":"default","claimName":"postgres-persistent-volume-claim"}</div><div class="FixedLine">(base) binildass-MacBook-Pro:~ binil$</div></div><div class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Listing 10-56</span><p class="SimplePara">Association Between Pods and PVCs</p></div></div></div></div>

          <div class="Para" id="Par186">This listing shows the association between the <span id="ITerm110">PostgreSQL pod</span> and its PVC. You can also see the association between the PVC and PV, shown in Listing <span class="InternalRef"><a href="#PC59">10-57</a></span>.<div class="ProgramCode" id="PC59"><div class="LineGroup"><div class="FixedLine">(base) binildass-MacBook-Pro:~ binil$ kubectl get pvc --all-namespaces -o json | jq -j '.items[] | "\(.metadata.namespace), \(.metadata.name), \(.spec.volumeName)\n"'</div><div class="FixedLine">default, postgres-persistent-volume-claim, pvc-2c90c05e-c233-44d4-8adb-5595da8edc3e</div><div class="FixedLine">(base) binildass-MacBook-Pro:~ binil$</div></div><div class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Listing 10-57</span><p class="SimplePara">Association Between PV and PVC</p></div></div></div></div>

          <div class="Para" id="Par187">To understand this, note what the <span id="ITerm111">Kubernetes documentation</span> says:<blockquote class="BlockQuote"><p class="Para ParaOneEmphasisChild" id="Par188"><em class="EmphasisTypeItalic ">A user creates, or in the case of dynamic provisioning, has already created, a PersistentVolumeClaim with a specific amount of storage requested and with certain access modes. A control loop in the master watches for new PVCs, finds a matching PV (if possible), and binds them together. If a PV was dynamically provisioned for a new PVC, the loop will always bind that PV to the PVC. Otherwise, the user will always get at least what they asked for, but the volume may be in excess of what was requested. Once bound, PersistentVolumeClaim binds are exclusive, regardless of how they were bound. A PVC to PV binding is a one-to-one mapping, using a ClaimRef which is a bidirectional binding between the PersistentVolume and the PersistentVolumeClaim.</em></p><p class="Para" id="Par189">—Kubernetes</p></blockquote></div>

          <p class="Para" id="Par190">This explains the behavior you saw earlier to some extent. Further details are beyond the scope of this discussion and you are advised to refer to the <span id="ITerm112">Kubernetes documentation</span>.</p>

          <div class="Para" id="Par191">Once you are done testing, you can stop and remove the microservice containers and clean the environment by using the <span class="EmphasisFontCategoryNonProportional ">clean.sh</span> script shown in Listing <span class="InternalRef"><a href="#PC60">10-58</a></span>.<div class="ProgramCode" id="PC60"><div class="LineGroup"><div class="FixedLine">mvn -Dmaven.test.skip=true clean</div><div class="FixedLine">kubectl delete -f product-web-service.yml</div><div class="FixedLine">kubectl delete -f product-web-deployment.yml</div><div class="FixedLine">kubectl delete -f product-server-service.yml</div><div class="FixedLine">kubectl delete -f product-server-deployment.yml</div><div class="FixedLine">kubectl delete -f postgres-svc.yml</div><div class="FixedLine">kubectl delete -f postgres-deployment.yml</div><div class="FixedLine">kubectl delete -f postgres-pvc.yml</div><div class="FixedLine">kubectl delete -f postgres-config.yml</div><div class="FixedLine">docker rmi -f ecom/product-web</div><div class="FixedLine">docker rmi -f ecom/product-server</div></div><div class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Listing 10-58</span><p class="SimplePara">The Script to Bring Down Microservices Kubernetes Pods (ch10\ch10-02\clean.sh)</p></div></div></div></div>

          <div class="Para" id="Par192">You can execute this script to stop and remove the microservice pods and clean the environment, as shown in Listing <span class="InternalRef"><a href="#PC61">10-59</a></span>, just like the way you cleaned up your environment in Listing <span class="InternalRef"><a href="#PC42">10-40</a></span>.<div class="ProgramCode" id="PC61"><div class="LineGroup"><div class="FixedLine">((base) binildass-MacBook-Pro:ch10-02 binil$ pwd</div><div class="FixedLine">/Users/binil/binil/code/mac/mybooks/docker-04/Code/ch10/ch10-02</div><div class="FixedLine">(base) binildass-MacBook-Pro:ch10-02 binil$ eval $(minikube docker-env)</div><div class="FixedLine">(base) binildass-MacBook-Pro:ch10-02 binil$ sh clean.sh</div><div class="FixedLine">...</div></div><div class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Listing 10-59</span><p class="SimplePara">Stopping Microservice Pods and Cleaning the Environment</p></div></div></div></div>

        </section>

      </section>

      <section class="Section1 RenderAsSection1" id="Sec38">

        <h2 class="Heading">Summary</h2>

        <p class="Para" id="Par193">You started your journey into containers in Chapters <span class="ExternalRef"><a href="Capítulo-09.html"><span class="RefSource">7</span></a></span> and <span class="ExternalRef"><a href="Capítulo-10.html"><span class="RefSource">8</span></a></span>, and in Chapter <span class="ExternalRef"><a href="Capítulo-11.html"><span class="RefSource">9</span></a></span>, you extended that learning to use Docker Compose to compose multiple microservice and database containers. During the start of this chapter, you learned that when you move from monolithic to microservices, you increase the number of moving parts, and so the overall complexity also increases. This is where better container management tools like Kubernetes pay off. This chapter included a quick introduction to Kubernetes and introduced the familiar microservices example interacting with both an SQL and a NoSQL database within the Kubernetes toolset. You are not finished yet, since you have yet to investigate integrating message brokers into your Kubernetes ecosystem. This is covered in Chapter <span class="ExternalRef"><a href="Capítulo-13.html"><span class="RefSource">11</span></a></span>.</p>

      </section>

    </div>

  </div>

</body>

</html>